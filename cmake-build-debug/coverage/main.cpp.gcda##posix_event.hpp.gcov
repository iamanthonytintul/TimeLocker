        -:    0:Source:/usr/include/boost/asio/detail/posix_event.hpp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/posix_event.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_POSIX_EVENT_HPP
        -:   12:#define BOOST_ASIO_DETAIL_POSIX_EVENT_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:
        -:   20:#if defined(BOOST_ASIO_HAS_PTHREADS)
        -:   21:
        -:   22:#include <pthread.h>
        -:   23:#include <boost/asio/detail/assert.hpp>
        -:   24:#include <boost/asio/detail/noncopyable.hpp>
        -:   25:
        -:   26:#include <boost/asio/detail/push_options.hpp>
        -:   27:
        -:   28:namespace boost {
        -:   29:namespace asio {
        -:   30:namespace detail {
        -:   31:
        -:   32:class posix_event
        -:   33:  : private noncopyable
        -:   34:{
        -:   35:public:
        -:   36:  // Constructor.
        -:   37:  BOOST_ASIO_DECL posix_event();
        -:   38:
        -:   39:  // Destructor.
    #####:   40:  ~posix_event()
    #####:   41:  {
    #####:   42:    ::pthread_cond_destroy(&cond_);
    %%%%%:   42-block  0
    #####:   43:  }
        -:   44:
        -:   45:  // Signal the event. (Retained for backward compatibility.)
        -:   46:  template <typename Lock>
        -:   47:  void signal(Lock& lock)
        -:   48:  {
        -:   49:    this->signal_all(lock);
        -:   50:  }
        -:   51:
        -:   52:  // Signal all waiters.
        -:   53:  template <typename Lock>
        1:   54:  void signal_all(Lock& lock)
        -:   55:  {
       1*:   56:    BOOST_ASIO_ASSERT(lock.locked());
        1:   56-block  0
    %%%%%:   56-block  1
        -:   57:    (void)lock;
        1:   58:    state_ |= 1;
        1:   59:    ::pthread_cond_broadcast(&cond_); // Ignore EINVAL.
        1:   59-block  0
        1:   60:  }
        -:   61:
        -:   62:  // Unlock the mutex and signal one waiter.
        -:   63:  template <typename Lock>
        2:   64:  void unlock_and_signal_one(Lock& lock)
        -:   65:  {
       2*:   66:    BOOST_ASIO_ASSERT(lock.locked());
        2:   66-block  0
    %%%%%:   66-block  1
        2:   67:    state_ |= 1;
        2:   68:    bool have_waiters = (state_ > 1);
        2:   69:    lock.unlock();
        2:   69-block  0
        2:   70:    if (have_waiters)
    #####:   71:      ::pthread_cond_signal(&cond_); // Ignore EINVAL.
    %%%%%:   71-block  0
        2:   72:  }
        -:   73:
        -:   74:  // If there's a waiter, unlock the mutex and signal it.
        -:   75:  template <typename Lock>
        7:   76:  bool maybe_unlock_and_signal_one(Lock& lock)
        -:   77:  {
       7*:   78:    BOOST_ASIO_ASSERT(lock.locked());
        7:   78-block  0
    %%%%%:   78-block  1
        7:   79:    state_ |= 1;
        7:   80:    if (state_ > 1)
        7:   80-block  0
        -:   81:    {
    #####:   82:      lock.unlock();
    %%%%%:   82-block  0
    #####:   83:      ::pthread_cond_signal(&cond_); // Ignore EINVAL.
    #####:   84:      return true;
        -:   85:    }
        7:   86:    return false;
        7:   86-block  0
        -:   87:  }
        -:   88:
        -:   89:  // Reset the event.
        -:   90:  template <typename Lock>
    #####:   91:  void clear(Lock& lock)
        -:   92:  {
    #####:   93:    BOOST_ASIO_ASSERT(lock.locked());
    %%%%%:   93-block  0
    %%%%%:   93-block  1
        -:   94:    (void)lock;
    #####:   95:    state_ &= ~std::size_t(1);
    #####:   96:  }
        -:   97:
        -:   98:  // Wait for the event to become signalled.
        -:   99:  template <typename Lock>
    #####:  100:  void wait(Lock& lock)
        -:  101:  {
    #####:  102:    BOOST_ASIO_ASSERT(lock.locked());
    %%%%%:  102-block  0
    %%%%%:  102-block  1
    #####:  103:    while ((state_ & 1) == 0)
    %%%%%:  103-block  0
        -:  104:    {
    #####:  105:      state_ += 2;
    #####:  106:      ::pthread_cond_wait(&cond_, &lock.mutex().mutex_); // Ignore EINVAL.
    %%%%%:  106-block  0
    #####:  107:      state_ -= 2;
        -:  108:    }
    #####:  109:  }
        -:  110:
        -:  111:  // Timed wait for the event to become signalled.
        -:  112:  template <typename Lock>
        -:  113:  bool wait_for_usec(Lock& lock, long usec)
        -:  114:  {
        -:  115:    BOOST_ASIO_ASSERT(lock.locked());
        -:  116:    if ((state_ & 1) == 0)
        -:  117:    {
        -:  118:      state_ += 2;
        -:  119:      timespec ts;
        -:  120:#if (defined(__MACH__) && defined(__APPLE__)) \
        -:  121:      || (defined(__ANDROID__) && (__ANDROID_API__ < 21) \
        -:  122:          && defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE))
        -:  123:      ts.tv_sec = usec / 1000000;
        -:  124:      ts.tv_nsec = (usec % 1000000) * 1000;
        -:  125:      ::pthread_cond_timedwait_relative_np(
        -:  126:          &cond_, &lock.mutex().mutex_, &ts); // Ignore EINVAL.
        -:  127:#else // (defined(__MACH__) && defined(__APPLE__))
        -:  128:      // || (defined(__ANDROID__) && (__ANDROID_API__ < 21)
        -:  129:      //     && defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE))
        -:  130:      if (::clock_gettime(CLOCK_MONOTONIC, &ts) == 0)
        -:  131:      {
        -:  132:        ts.tv_sec += usec / 1000000;
        -:  133:        ts.tv_nsec += (usec % 1000000) * 1000;
        -:  134:        ts.tv_sec += ts.tv_nsec / 1000000000;
        -:  135:        ts.tv_nsec = ts.tv_nsec % 1000000000;
        -:  136:        ::pthread_cond_timedwait(&cond_,
        -:  137:            &lock.mutex().mutex_, &ts); // Ignore EINVAL.
        -:  138:      }
        -:  139:#endif // (defined(__MACH__) && defined(__APPLE__))
        -:  140:       // || (defined(__ANDROID__) && (__ANDROID_API__ < 21)
        -:  141:       //     && defined(HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE))
        -:  142:      state_ -= 2;
        -:  143:    }
        -:  144:    return (state_ & 1) != 0;
        -:  145:  }
        -:  146:
        -:  147:private:
        -:  148:  ::pthread_cond_t cond_;
        -:  149:  std::size_t state_;
        -:  150:};
        -:  151:
        -:  152:} // namespace detail
        -:  153:} // namespace asio
        -:  154:} // namespace boost
        -:  155:
        -:  156:#include <boost/asio/detail/pop_options.hpp>
        -:  157:
        -:  158:#if defined(BOOST_ASIO_HEADER_ONLY)
        -:  159:# include <boost/asio/detail/impl/posix_event.ipp>
        -:  160:#endif // defined(BOOST_ASIO_HEADER_ONLY)
        -:  161:
        -:  162:#endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -:  163:
        -:  164:#endif // BOOST_ASIO_DETAIL_POSIX_EVENT_HPP
