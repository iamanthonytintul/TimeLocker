        -:    0:Source:/usr/include/boost/asio/detail/impl/socket_ops.ipp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/impl/socket_ops.ipp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
        -:   12:#define BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:
        -:   20:#include <cctype>
        -:   21:#include <cstdio>
        -:   22:#include <cstdlib>
        -:   23:#include <cstring>
        -:   24:#include <cerrno>
        -:   25:#include <new>
        -:   26:#include <boost/asio/detail/assert.hpp>
        -:   27:#include <boost/asio/detail/socket_ops.hpp>
        -:   28:#include <boost/asio/error.hpp>
        -:   29:
        -:   30:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   31:# include <codecvt>
        -:   32:# include <locale>
        -:   33:# include <string>
        -:   34:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   35:
        -:   36:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__) \
        -:   37:  || defined(__MACH__) && defined(__APPLE__)
        -:   38:# if defined(BOOST_ASIO_HAS_PTHREADS)
        -:   39:#  include <pthread.h>
        -:   40:# endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -:   41:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   42:       // || defined(__MACH__) && defined(__APPLE__)
        -:   43:
        -:   44:#include <boost/asio/detail/push_options.hpp>
        -:   45:
        -:   46:namespace boost {
        -:   47:namespace asio {
        -:   48:namespace detail {
        -:   49:namespace socket_ops {
        -:   50:
        -:   51:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   52:
        -:   53:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   54:struct msghdr { int msg_namelen; };
        -:   55:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   56:
        -:   57:#if defined(__hpux)
        -:   58:// HP-UX doesn't declare these functions extern "C", so they are declared again
        -:   59:// here to avoid linker errors about undefined symbols.
        -:   60:extern "C" char* if_indextoname(unsigned int, char*);
        -:   61:extern "C" unsigned int if_nametoindex(const char*);
        -:   62:#endif // defined(__hpux)
        -:   63:
        -:   64:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   65:
    #####:   66:inline void clear_last_error()
        -:   67:{
        -:   68:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   69:  WSASetLastError(0);
        -:   70:#else
    #####:   71:  errno = 0;
        -:   72:#endif
    #####:   73:}
        -:   74:
        -:   75:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   76:
        -:   77:template <typename ReturnType>
       4*:   78:inline ReturnType error_wrapper(ReturnType return_value,
        -:   79:    boost::system::error_code& ec)
        -:   80:{
        -:   81:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   82:  ec = boost::system::error_code(WSAGetLastError(),
        -:   83:      boost::asio::error::get_system_category());
        -:   84:#else
       4*:   85:  ec = boost::system::error_code(errno,
        -:   86:      boost::asio::error::get_system_category());
        -:   87:#endif
       4*:   88:  return return_value;
        -:   89:}
------------------
_ZN5boost4asio6detail10socket_ops13error_wrapperIlEET_S4_RNS_6system10error_codeE:
        4:   78:inline ReturnType error_wrapper(ReturnType return_value,
        -:   79:    boost::system::error_code& ec)
        -:   80:{
        -:   81:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   82:  ec = boost::system::error_code(WSAGetLastError(),
        -:   83:      boost::asio::error::get_system_category());
        -:   84:#else
        4:   85:  ec = boost::system::error_code(errno,
        4:   85-block  0
        -:   86:      boost::asio::error::get_system_category());
        -:   87:#endif
        4:   88:  return return_value;
        -:   89:}
------------------
_ZN5boost4asio6detail10socket_ops13error_wrapperIiEET_S4_RNS_6system10error_codeE:
    #####:   78:inline ReturnType error_wrapper(ReturnType return_value,
        -:   79:    boost::system::error_code& ec)
        -:   80:{
        -:   81:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   82:  ec = boost::system::error_code(WSAGetLastError(),
        -:   83:      boost::asio::error::get_system_category());
        -:   84:#else
    #####:   85:  ec = boost::system::error_code(errno,
    %%%%%:   85-block  0
        -:   86:      boost::asio::error::get_system_category());
        -:   87:#endif
    #####:   88:  return return_value;
        -:   89:}
------------------
        -:   90:
        -:   91:template <typename SockLenType>
        -:   92:inline socket_type call_accept(SockLenType msghdr::*,
        -:   93:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -:   94:{
        -:   95:  SockLenType tmp_addrlen = addrlen ? (SockLenType)*addrlen : 0;
        -:   96:  socket_type result = ::accept(s, addr, addrlen ? &tmp_addrlen : 0);
        -:   97:  if (addrlen)
        -:   98:    *addrlen = (std::size_t)tmp_addrlen;
        -:   99:  return result;
        -:  100:}
        -:  101:
        -:  102:socket_type accept(socket_type s, socket_addr_type* addr,
        -:  103:    std::size_t* addrlen, boost::system::error_code& ec)
        -:  104:{
        -:  105:  if (s == invalid_socket)
        -:  106:  {
        -:  107:    ec = boost::asio::error::bad_descriptor;
        -:  108:    return invalid_socket;
        -:  109:  }
        -:  110:
        -:  111:  clear_last_error();
        -:  112:
        -:  113:  socket_type new_s = error_wrapper(call_accept(
        -:  114:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -:  115:  if (new_s == invalid_socket)
        -:  116:    return new_s;
        -:  117:
        -:  118:#if defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
        -:  119:  int optval = 1;
        -:  120:  int result = error_wrapper(::setsockopt(new_s,
        -:  121:        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
        -:  122:  if (result != 0)
        -:  123:  {
        -:  124:    ::close(new_s);
        -:  125:    return invalid_socket;
        -:  126:  }
        -:  127:#endif
        -:  128:
        -:  129:  ec = boost::system::error_code();
        -:  130:  return new_s;
        -:  131:}
        -:  132:
        -:  133:socket_type sync_accept(socket_type s, state_type state,
        -:  134:    socket_addr_type* addr, std::size_t* addrlen, boost::system::error_code& ec)
        -:  135:{
        -:  136:  // Accept a socket.
        -:  137:  for (;;)
        -:  138:  {
        -:  139:    // Try to complete the operation without blocking.
        -:  140:    socket_type new_socket = socket_ops::accept(s, addr, addrlen, ec);
        -:  141:
        -:  142:    // Check if operation succeeded.
        -:  143:    if (new_socket != invalid_socket)
        -:  144:      return new_socket;
        -:  145:
        -:  146:    // Operation failed.
        -:  147:    if (ec == boost::asio::error::would_block
        -:  148:        || ec == boost::asio::error::try_again)
        -:  149:    {
        -:  150:      if (state & user_set_non_blocking)
        -:  151:        return invalid_socket;
        -:  152:      // Fall through to retry operation.
        -:  153:    }
        -:  154:    else if (ec == boost::asio::error::connection_aborted)
        -:  155:    {
        -:  156:      if (state & enable_connection_aborted)
        -:  157:        return invalid_socket;
        -:  158:      // Fall through to retry operation.
        -:  159:    }
        -:  160:#if defined(EPROTO)
        -:  161:    else if (ec.value() == EPROTO)
        -:  162:    {
        -:  163:      if (state & enable_connection_aborted)
        -:  164:        return invalid_socket;
        -:  165:      // Fall through to retry operation.
        -:  166:    }
        -:  167:#endif // defined(EPROTO)
        -:  168:    else
        -:  169:      return invalid_socket;
        -:  170:
        -:  171:    // Wait for socket to become ready.
        -:  172:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  173:      return invalid_socket;
        -:  174:  }
        -:  175:}
        -:  176:
        -:  177:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  178:
        -:  179:void complete_iocp_accept(socket_type s,
        -:  180:    void* output_buffer, DWORD address_length,
        -:  181:    socket_addr_type* addr, std::size_t* addrlen,
        -:  182:    socket_type new_socket, boost::system::error_code& ec)
        -:  183:{
        -:  184:  // Map non-portable errors to their portable counterparts.
        -:  185:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  186:    ec = boost::asio::error::connection_aborted;
        -:  187:
        -:  188:  if (!ec)
        -:  189:  {
        -:  190:    // Get the address of the peer.
        -:  191:    if (addr && addrlen)
        -:  192:    {
        -:  193:      LPSOCKADDR local_addr = 0;
        -:  194:      int local_addr_length = 0;
        -:  195:      LPSOCKADDR remote_addr = 0;
        -:  196:      int remote_addr_length = 0;
        -:  197:      GetAcceptExSockaddrs(output_buffer, 0, address_length,
        -:  198:          address_length, &local_addr, &local_addr_length,
        -:  199:          &remote_addr, &remote_addr_length);
        -:  200:      if (static_cast<std::size_t>(remote_addr_length) > *addrlen)
        -:  201:      {
        -:  202:        ec = boost::asio::error::invalid_argument;
        -:  203:      }
        -:  204:      else
        -:  205:      {
        -:  206:        using namespace std; // For memcpy.
        -:  207:        memcpy(addr, remote_addr, remote_addr_length);
        -:  208:        *addrlen = static_cast<std::size_t>(remote_addr_length);
        -:  209:      }
        -:  210:    }
        -:  211:
        -:  212:    // Need to set the SO_UPDATE_ACCEPT_CONTEXT option so that getsockname
        -:  213:    // and getpeername will work on the accepted socket.
        -:  214:    SOCKET update_ctx_param = s;
        -:  215:    socket_ops::state_type state = 0;
        -:  216:    socket_ops::setsockopt(new_socket, state,
        -:  217:          SOL_SOCKET, SO_UPDATE_ACCEPT_CONTEXT,
        -:  218:          &update_ctx_param, sizeof(SOCKET), ec);
        -:  219:  }
        -:  220:}
        -:  221:
        -:  222:#else // defined(BOOST_ASIO_HAS_IOCP)
        -:  223:
        -:  224:bool non_blocking_accept(socket_type s,
        -:  225:    state_type state, socket_addr_type* addr, std::size_t* addrlen,
        -:  226:    boost::system::error_code& ec, socket_type& new_socket)
        -:  227:{
        -:  228:  for (;;)
        -:  229:  {
        -:  230:    // Accept the waiting connection.
        -:  231:    new_socket = socket_ops::accept(s, addr, addrlen, ec);
        -:  232:
        -:  233:    // Check if operation succeeded.
        -:  234:    if (new_socket != invalid_socket)
        -:  235:      return true;
        -:  236:
        -:  237:    // Retry operation if interrupted by signal.
        -:  238:    if (ec == boost::asio::error::interrupted)
        -:  239:      continue;
        -:  240:
        -:  241:    // Operation failed.
        -:  242:    if (ec == boost::asio::error::would_block
        -:  243:        || ec == boost::asio::error::try_again)
        -:  244:    {
        -:  245:      // Fall through to retry operation.
        -:  246:    }
        -:  247:    else if (ec == boost::asio::error::connection_aborted)
        -:  248:    {
        -:  249:      if (state & enable_connection_aborted)
        -:  250:        return true;
        -:  251:      // Fall through to retry operation.
        -:  252:    }
        -:  253:#if defined(EPROTO)
        -:  254:    else if (ec.value() == EPROTO)
        -:  255:    {
        -:  256:      if (state & enable_connection_aborted)
        -:  257:        return true;
        -:  258:      // Fall through to retry operation.
        -:  259:    }
        -:  260:#endif // defined(EPROTO)
        -:  261:    else
        -:  262:      return true;
        -:  263:
        -:  264:    return false;
        -:  265:  }
        -:  266:}
        -:  267:
        -:  268:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  269:
        -:  270:template <typename SockLenType>
        -:  271:inline int call_bind(SockLenType msghdr::*,
        -:  272:    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
        -:  273:{
        -:  274:  return ::bind(s, addr, (SockLenType)addrlen);
        -:  275:}
        -:  276:
        -:  277:int bind(socket_type s, const socket_addr_type* addr,
        -:  278:    std::size_t addrlen, boost::system::error_code& ec)
        -:  279:{
        -:  280:  if (s == invalid_socket)
        -:  281:  {
        -:  282:    ec = boost::asio::error::bad_descriptor;
        -:  283:    return socket_error_retval;
        -:  284:  }
        -:  285:
        -:  286:  clear_last_error();
        -:  287:  int result = error_wrapper(call_bind(
        -:  288:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -:  289:  if (result == 0)
        -:  290:    ec = boost::system::error_code();
        -:  291:  return result;
        -:  292:}
        -:  293:
    #####:  294:int close(socket_type s, state_type& state,
        -:  295:    bool destruction, boost::system::error_code& ec)
        -:  296:{
    #####:  297:  int result = 0;
    #####:  298:  if (s != invalid_socket)
    %%%%%:  298-block  0
        -:  299:  {
        -:  300:    // We don't want the destructor to block, so set the socket to linger in
        -:  301:    // the background. If the user doesn't like this behaviour then they need
        -:  302:    // to explicitly close the socket.
    #####:  303:    if (destruction && (state & user_set_linger))
    %%%%%:  303-block  0
    %%%%%:  303-block  1
        -:  304:    {
        -:  305:      ::linger opt;
    #####:  306:      opt.l_onoff = 0;
    #####:  307:      opt.l_linger = 0;
    #####:  308:      boost::system::error_code ignored_ec;
    #####:  309:      socket_ops::setsockopt(s, state, SOL_SOCKET,
    %%%%%:  309-block  0
        -:  310:          SO_LINGER, &opt, sizeof(opt), ignored_ec);
        -:  311:    }
        -:  312:
    #####:  313:    clear_last_error();
    %%%%%:  313-block  0
        -:  314:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  315:    result = error_wrapper(::closesocket(s), ec);
        -:  316:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  317:    result = error_wrapper(::close(s), ec);
        -:  318:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  319:
    #####:  320:    if (result != 0
    #####:  321:        && (ec == boost::asio::error::would_block
    %%%%%:  321-block  0
    %%%%%:  321-block  1
    %%%%%:  321-block  2
    #####:  322:          || ec == boost::asio::error::try_again))
    %%%%%:  322-block  0
    %%%%%:  322-block  1
        -:  323:    {
        -:  324:      // According to UNIX Network Programming Vol. 1, it is possible for
        -:  325:      // close() to fail with EWOULDBLOCK under certain circumstances. What
        -:  326:      // isn't clear is the state of the descriptor after this error. The one
        -:  327:      // current OS where this behaviour is seen, Windows, says that the socket
        -:  328:      // remains open. Therefore we'll put the descriptor back into blocking
        -:  329:      // mode and have another attempt at closing it.
        -:  330:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  331:      ioctl_arg_type arg = 0;
        -:  332:      ::ioctlsocket(s, FIONBIO, &arg);
        -:  333:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  334:# if defined(__SYMBIAN32__) || defined(__EMSCRIPTEN__)
        -:  335:      int flags = ::fcntl(s, F_GETFL, 0);
        -:  336:      if (flags >= 0)
        -:  337:        ::fcntl(s, F_SETFL, flags & ~O_NONBLOCK);
        -:  338:# else // defined(__SYMBIAN32__) || defined(__EMSCRIPTEN__)
    #####:  339:      ioctl_arg_type arg = 0;
    #####:  340:      ::ioctl(s, FIONBIO, &arg);
    %%%%%:  340-block  0
        -:  341:# endif // defined(__SYMBIAN32__) || defined(__EMSCRIPTEN__)
        -:  342:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  343:      state &= ~non_blocking;
        -:  344:
    #####:  345:      clear_last_error();
        -:  346:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  347:      result = error_wrapper(::closesocket(s), ec);
        -:  348:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
    #####:  349:      result = error_wrapper(::close(s), ec);
    %%%%%:  349-block  0
        -:  350:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  351:    }
        -:  352:  }
        -:  353:
    #####:  354:  if (result == 0)
    %%%%%:  354-block  0
    #####:  355:    ec = boost::system::error_code();
    %%%%%:  355-block  0
    #####:  356:  return result;
    %%%%%:  356-block  0
    %%%%%:  356-block  1
        -:  357:}
        -:  358:
        -:  359:bool set_user_non_blocking(socket_type s,
        -:  360:    state_type& state, bool value, boost::system::error_code& ec)
        -:  361:{
        -:  362:  if (s == invalid_socket)
        -:  363:  {
        -:  364:    ec = boost::asio::error::bad_descriptor;
        -:  365:    return false;
        -:  366:  }
        -:  367:
        -:  368:  clear_last_error();
        -:  369:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  370:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  371:  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
        -:  372:#elif defined(__SYMBIAN32__) || defined(__EMSCRIPTEN__)
        -:  373:  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
        -:  374:  if (result >= 0)
        -:  375:  {
        -:  376:    clear_last_error();
        -:  377:    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
        -:  378:    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
        -:  379:  }
        -:  380:#else
        -:  381:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  382:  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
        -:  383:#endif
        -:  384:
        -:  385:  if (result >= 0)
        -:  386:  {
        -:  387:    ec = boost::system::error_code();
        -:  388:    if (value)
        -:  389:      state |= user_set_non_blocking;
        -:  390:    else
        -:  391:    {
        -:  392:      // Clearing the user-set non-blocking mode always overrides any
        -:  393:      // internally-set non-blocking flag. Any subsequent asynchronous
        -:  394:      // operations will need to re-enable non-blocking I/O.
        -:  395:      state &= ~(user_set_non_blocking | internal_non_blocking);
        -:  396:    }
        -:  397:    return true;
        -:  398:  }
        -:  399:
        -:  400:  return false;
        -:  401:}
        -:  402:
        1:  403:bool set_internal_non_blocking(socket_type s,
        -:  404:    state_type& state, bool value, boost::system::error_code& ec)
        -:  405:{
        1:  406:  if (s == invalid_socket)
        1:  406-block  0
        -:  407:  {
    #####:  408:    ec = boost::asio::error::bad_descriptor;
    %%%%%:  408-block  0
    #####:  409:    return false;
        -:  410:  }
        -:  411:
       1*:  412:  if (!value && (state & user_set_non_blocking))
        1:  412-block  0
    %%%%%:  412-block  1
        -:  413:  {
        -:  414:    // It does not make sense to clear the internal non-blocking flag if the
        -:  415:    // user still wants non-blocking behaviour. Return an error and let the
        -:  416:    // caller figure out whether to update the user-set non-blocking flag.
    #####:  417:    ec = boost::asio::error::invalid_argument;
    %%%%%:  417-block  0
    #####:  418:    return false;
        -:  419:  }
        -:  420:
        1:  421:  clear_last_error();
        1:  421-block  0
        -:  422:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  423:  ioctl_arg_type arg = (value ? 1 : 0);
        -:  424:  int result = error_wrapper(::ioctlsocket(s, FIONBIO, &arg), ec);
        -:  425:#elif defined(__SYMBIAN32__) || defined(__EMSCRIPTEN__)
        -:  426:  int result = error_wrapper(::fcntl(s, F_GETFL, 0), ec);
        -:  427:  if (result >= 0)
        -:  428:  {
        -:  429:    clear_last_error();
        -:  430:    int flag = (value ? (result | O_NONBLOCK) : (result & ~O_NONBLOCK));
        -:  431:    result = error_wrapper(::fcntl(s, F_SETFL, flag), ec);
        -:  432:  }
        -:  433:#else
       1*:  434:  ioctl_arg_type arg = (value ? 1 : 0);
        1:  434-block  0
    %%%%%:  434-block  1
        1:  435:  int result = error_wrapper(::ioctl(s, FIONBIO, &arg), ec);
        1:  435-block  0
        -:  436:#endif
        -:  437:
        1:  438:  if (result >= 0)
        -:  439:  {
        1:  440:    ec = boost::system::error_code();
        1:  440-block  0
        1:  441:    if (value)
        1:  442:      state |= internal_non_blocking;
        1:  442-block  0
        -:  443:    else
    #####:  444:      state &= ~internal_non_blocking;
    %%%%%:  444-block  0
        1:  445:    return true;
        1:  445-block  0
        -:  446:  }
        -:  447:
    #####:  448:  return false;
    %%%%%:  448-block  0
        -:  449:}
        -:  450:
        1:  451:int shutdown(socket_type s, int what, boost::system::error_code& ec)
        -:  452:{
        1:  453:  if (s == invalid_socket)
        1:  453-block  0
        -:  454:  {
    #####:  455:    ec = boost::asio::error::bad_descriptor;
    %%%%%:  455-block  0
    #####:  456:    return socket_error_retval;
        -:  457:  }
        -:  458:
        1:  459:  clear_last_error();
        1:  459-block  0
        1:  460:  int result = error_wrapper(::shutdown(s, what), ec);
        1:  461:  if (result == 0)
        1:  462:    ec = boost::system::error_code();
        1:  462-block  0
        1:  463:  return result;
        1:  463-block  0
        -:  464:}
        -:  465:
        -:  466:template <typename SockLenType>
        1:  467:inline int call_connect(SockLenType msghdr::*,
        -:  468:    socket_type s, const socket_addr_type* addr, std::size_t addrlen)
        -:  469:{
        1:  470:  return ::connect(s, addr, (SockLenType)addrlen);
        1:  470-block  0
        -:  471:}
        -:  472:
        1:  473:int connect(socket_type s, const socket_addr_type* addr,
        -:  474:    std::size_t addrlen, boost::system::error_code& ec)
        -:  475:{
        1:  476:  if (s == invalid_socket)
        1:  476-block  0
        -:  477:  {
    #####:  478:    ec = boost::asio::error::bad_descriptor;
    %%%%%:  478-block  0
    #####:  479:    return socket_error_retval;
        -:  480:  }
        -:  481:
        1:  482:  clear_last_error();
        1:  482-block  0
        1:  483:  int result = error_wrapper(call_connect(
        -:  484:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        1:  485:  if (result == 0)
    #####:  486:    ec = boost::system::error_code();
    %%%%%:  486-block  0
        -:  487:#if defined(__linux__)
        1:  488:  else if (ec == boost::asio::error::try_again)
        1:  488-block  0
    #####:  489:    ec = boost::asio::error::no_buffer_space;
    %%%%%:  489-block  0
        -:  490:#endif // defined(__linux__)
        1:  491:  return result;
        1:  491-block  0
        -:  492:}
        -:  493:
        -:  494:void sync_connect(socket_type s, const socket_addr_type* addr,
        -:  495:    std::size_t addrlen, boost::system::error_code& ec)
        -:  496:{
        -:  497:  // Perform the connect operation.
        -:  498:  socket_ops::connect(s, addr, addrlen, ec);
        -:  499:  if (ec != boost::asio::error::in_progress
        -:  500:      && ec != boost::asio::error::would_block)
        -:  501:  {
        -:  502:    // The connect operation finished immediately.
        -:  503:    return;
        -:  504:  }
        -:  505:
        -:  506:  // Wait for socket to become ready.
        -:  507:  if (socket_ops::poll_connect(s, -1, ec) < 0)
        -:  508:    return;
        -:  509:
        -:  510:  // Get the error code from the connect operation.
        -:  511:  int connect_error = 0;
        -:  512:  size_t connect_error_len = sizeof(connect_error);
        -:  513:  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
        -:  514:        &connect_error, &connect_error_len, ec) == socket_error_retval)
        -:  515:    return;
        -:  516:
        -:  517:  // Return the result of the connect operation.
        -:  518:  ec = boost::system::error_code(connect_error,
        -:  519:      boost::asio::error::get_system_category());
        -:  520:}
        -:  521:
        -:  522:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  523:
        -:  524:void complete_iocp_connect(socket_type s, boost::system::error_code& ec)
        -:  525:{
        -:  526:  // Map non-portable errors to their portable counterparts.
        -:  527:  switch (ec.value())
        -:  528:  {
        -:  529:  case ERROR_CONNECTION_REFUSED:
        -:  530:    ec = boost::asio::error::connection_refused;
        -:  531:    break;
        -:  532:  case ERROR_NETWORK_UNREACHABLE:
        -:  533:    ec = boost::asio::error::network_unreachable;
        -:  534:    break;
        -:  535:  case ERROR_HOST_UNREACHABLE:
        -:  536:    ec = boost::asio::error::host_unreachable;
        -:  537:    break;
        -:  538:  case ERROR_SEM_TIMEOUT:
        -:  539:    ec = boost::asio::error::timed_out;
        -:  540:    break;
        -:  541:  default:
        -:  542:    break;
        -:  543:  }
        -:  544:
        -:  545:  if (!ec)
        -:  546:  {
        -:  547:    // Need to set the SO_UPDATE_CONNECT_CONTEXT option so that getsockname
        -:  548:    // and getpeername will work on the connected socket.
        -:  549:    socket_ops::state_type state = 0;
        -:  550:    const int so_update_connect_context = 0x7010;
        -:  551:    socket_ops::setsockopt(s, state, SOL_SOCKET,
        -:  552:        so_update_connect_context, 0, 0, ec);
        -:  553:  }
        -:  554:}
        -:  555:
        -:  556:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  557:
        1:  558:bool non_blocking_connect(socket_type s, boost::system::error_code& ec)
        -:  559:{
        -:  560:  // Check if the connect operation has finished. This is required since we may
        -:  561:  // get spurious readiness notifications from the reactor.
        -:  562:#if defined(BOOST_ASIO_WINDOWS) \
        -:  563:  || defined(__CYGWIN__) \
        -:  564:  || defined(__SYMBIAN32__)
        -:  565:  fd_set write_fds;
        -:  566:  FD_ZERO(&write_fds);
        -:  567:  FD_SET(s, &write_fds);
        -:  568:  fd_set except_fds;
        -:  569:  FD_ZERO(&except_fds);
        -:  570:  FD_SET(s, &except_fds);
        -:  571:  timeval zero_timeout;
        -:  572:  zero_timeout.tv_sec = 0;
        -:  573:  zero_timeout.tv_usec = 0;
        -:  574:  int ready = ::select(s + 1, 0, &write_fds, &except_fds, &zero_timeout);
        -:  575:#else // defined(BOOST_ASIO_WINDOWS)
        -:  576:      // || defined(__CYGWIN__)
        -:  577:      // || defined(__SYMBIAN32__)
        -:  578:  pollfd fds;
        1:  579:  fds.fd = s;
        1:  580:  fds.events = POLLOUT;
        1:  581:  fds.revents = 0;
        1:  582:  int ready = ::poll(&fds, 1, 0);
        1:  582-block  0
        -:  583:#endif // defined(BOOST_ASIO_WINDOWS)
        -:  584:       // || defined(__CYGWIN__)
        -:  585:       // || defined(__SYMBIAN32__)
        1:  586:  if (ready == 0)
        1:  586-block  0
        -:  587:  {
        -:  588:    // The asynchronous connect operation is still in progress.
    #####:  589:    return false;
    %%%%%:  589-block  0
        -:  590:  }
        -:  591:
        -:  592:  // Get the error code from the connect operation.
        1:  593:  int connect_error = 0;
        1:  594:  size_t connect_error_len = sizeof(connect_error);
        1:  595:  if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_ERROR,
        1:  595-block  0
        1:  596:        &connect_error, &connect_error_len, ec) == 0)
        1:  596-block  0
        -:  597:  {
        1:  598:    if (connect_error)
        1:  598-block  0
        -:  599:    {
    #####:  600:      ec = boost::system::error_code(connect_error,
    %%%%%:  600-block  0
        -:  601:          boost::asio::error::get_system_category());
        -:  602:    }
        -:  603:    else
        1:  604:      ec = boost::system::error_code();
        1:  604-block  0
        -:  605:  }
        -:  606:
        1:  607:  return true;
        1:  607-block  0
        -:  608:}
        -:  609:
        -:  610:int socketpair(int af, int type, int protocol,
        -:  611:    socket_type sv[2], boost::system::error_code& ec)
        -:  612:{
        -:  613:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  614:  (void)(af);
        -:  615:  (void)(type);
        -:  616:  (void)(protocol);
        -:  617:  (void)(sv);
        -:  618:  ec = boost::asio::error::operation_not_supported;
        -:  619:  return socket_error_retval;
        -:  620:#else
        -:  621:  clear_last_error();
        -:  622:  int result = error_wrapper(::socketpair(af, type, protocol, sv), ec);
        -:  623:  if (result == 0)
        -:  624:    ec = boost::system::error_code();
        -:  625:  return result;
        -:  626:#endif
        -:  627:}
        -:  628:
        -:  629:bool sockatmark(socket_type s, boost::system::error_code& ec)
        -:  630:{
        -:  631:  if (s == invalid_socket)
        -:  632:  {
        -:  633:    ec = boost::asio::error::bad_descriptor;
        -:  634:    return false;
        -:  635:  }
        -:  636:
        -:  637:#if defined(SIOCATMARK)
        -:  638:  ioctl_arg_type value = 0;
        -:  639:# if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  640:  int result = error_wrapper(::ioctlsocket(s, SIOCATMARK, &value), ec);
        -:  641:# else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  642:  int result = error_wrapper(::ioctl(s, SIOCATMARK, &value), ec);
        -:  643:# endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  644:  if (result == 0)
        -:  645:    ec = boost::system::error_code();
        -:  646:# if defined(ENOTTY)
        -:  647:  if (ec.value() == ENOTTY)
        -:  648:    ec = boost::asio::error::not_socket;
        -:  649:# endif // defined(ENOTTY)
        -:  650:#else // defined(SIOCATMARK)
        -:  651:  int value = error_wrapper(::sockatmark(s), ec);
        -:  652:  if (value != -1)
        -:  653:    ec = boost::system::error_code();
        -:  654:#endif // defined(SIOCATMARK)
        -:  655:
        -:  656:  return ec ? false : value != 0;
        -:  657:}
        -:  658:
        -:  659:size_t available(socket_type s, boost::system::error_code& ec)
        -:  660:{
        -:  661:  if (s == invalid_socket)
        -:  662:  {
        -:  663:    ec = boost::asio::error::bad_descriptor;
        -:  664:    return 0;
        -:  665:  }
        -:  666:
        -:  667:  ioctl_arg_type value = 0;
        -:  668:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  669:  int result = error_wrapper(::ioctlsocket(s, FIONREAD, &value), ec);
        -:  670:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  671:  int result = error_wrapper(::ioctl(s, FIONREAD, &value), ec);
        -:  672:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  673:  if (result == 0)
        -:  674:    ec = boost::system::error_code();
        -:  675:#if defined(ENOTTY)
        -:  676:  if (ec.value() == ENOTTY)
        -:  677:    ec = boost::asio::error::not_socket;
        -:  678:#endif // defined(ENOTTY)
        -:  679:
        -:  680:  return ec ? static_cast<size_t>(0) : static_cast<size_t>(value);
        -:  681:}
        -:  682:
        -:  683:int listen(socket_type s, int backlog, boost::system::error_code& ec)
        -:  684:{
        -:  685:  if (s == invalid_socket)
        -:  686:  {
        -:  687:    ec = boost::asio::error::bad_descriptor;
        -:  688:    return socket_error_retval;
        -:  689:  }
        -:  690:
        -:  691:  clear_last_error();
        -:  692:  int result = error_wrapper(::listen(s, backlog), ec);
        -:  693:  if (result == 0)
        -:  694:    ec = boost::system::error_code();
        -:  695:  return result;
        -:  696:}
        -:  697:
        -:  698:inline void init_buf_iov_base(void*& base, void* addr)
        -:  699:{
        -:  700:  base = addr;
        -:  701:}
        -:  702:
        -:  703:template <typename T>
        -:  704:inline void init_buf_iov_base(T& base, void* addr)
        -:  705:{
        -:  706:  base = static_cast<T>(addr);
        -:  707:}
        -:  708:
        -:  709:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  710:typedef WSABUF buffer;
        -:  711:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  712:typedef iovec buffer;
        -:  713:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  714:
        -:  715:void init_buf(buffer& b, void* data, size_t size)
        -:  716:{
        -:  717:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  718:  b.buffer = static_cast<char*>(data);
        -:  719:  b.len = static_cast<u_long>(size);
        -:  720:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  721:  init_buf_iov_base(b.iov_base, data);
        -:  722:  b.iov_len = size;
        -:  723:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  724:}
        -:  725:
        -:  726:void init_buf(buffer& b, const void* data, size_t size)
        -:  727:{
        -:  728:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  729:  b.buffer = static_cast<char*>(const_cast<void*>(data));
        -:  730:  b.len = static_cast<u_long>(size);
        -:  731:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  732:  init_buf_iov_base(b.iov_base, const_cast<void*>(data));
        -:  733:  b.iov_len = size;
        -:  734:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  735:}
        -:  736:
        -:  737:inline void init_msghdr_msg_name(void*& name, socket_addr_type* addr)
        -:  738:{
        -:  739:  name = addr;
        -:  740:}
        -:  741:
        -:  742:inline void init_msghdr_msg_name(void*& name, const socket_addr_type* addr)
        -:  743:{
        -:  744:  name = const_cast<socket_addr_type*>(addr);
        -:  745:}
        -:  746:
        -:  747:template <typename T>
        -:  748:inline void init_msghdr_msg_name(T& name, socket_addr_type* addr)
        -:  749:{
        -:  750:  name = reinterpret_cast<T>(addr);
        -:  751:}
        -:  752:
        -:  753:template <typename T>
        -:  754:inline void init_msghdr_msg_name(T& name, const socket_addr_type* addr)
        -:  755:{
        -:  756:  name = reinterpret_cast<T>(const_cast<socket_addr_type*>(addr));
        -:  757:}
        -:  758:
        3:  759:signed_size_type recv(socket_type s, buffer* bufs, size_t count,
        -:  760:    int flags, boost::system::error_code& ec)
        -:  761:{
        3:  762:  clear_last_error();
        3:  762-block  0
        -:  763:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  764:  // Receive some data.
        -:  765:  DWORD recv_buf_count = static_cast<DWORD>(count);
        -:  766:  DWORD bytes_transferred = 0;
        -:  767:  DWORD recv_flags = flags;
        -:  768:  int result = error_wrapper(::WSARecv(s, bufs,
        -:  769:        recv_buf_count, &bytes_transferred, &recv_flags, 0, 0), ec);
        -:  770:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  771:    ec = boost::asio::error::connection_reset;
        -:  772:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  773:    ec = boost::asio::error::connection_refused;
        -:  774:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  775:    result = 0;
        -:  776:  if (result != 0)
        -:  777:    return socket_error_retval;
        -:  778:  ec = boost::system::error_code();
        -:  779:  return bytes_transferred;
        -:  780:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        3:  781:  msghdr msg = msghdr();
        3:  782:  msg.msg_iov = bufs;
        3:  783:  msg.msg_iovlen = static_cast<int>(count);
        3:  784:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
        3:  784-block  0
        3:  785:  if (result >= 0)
        2:  786:    ec = boost::system::error_code();
        2:  786-block  0
        3:  787:  return result;
        3:  787-block  0
        3:  787-block  1
        -:  788:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  789:}
        -:  790:
        -:  791:size_t sync_recv(socket_type s, state_type state, buffer* bufs,
        -:  792:    size_t count, int flags, bool all_empty, boost::system::error_code& ec)
        -:  793:{
        -:  794:  if (s == invalid_socket)
        -:  795:  {
        -:  796:    ec = boost::asio::error::bad_descriptor;
        -:  797:    return 0;
        -:  798:  }
        -:  799:
        -:  800:  // A request to read 0 bytes on a stream is a no-op.
        -:  801:  if (all_empty && (state & stream_oriented))
        -:  802:  {
        -:  803:    ec = boost::system::error_code();
        -:  804:    return 0;
        -:  805:  }
        -:  806:
        -:  807:  // Read some data.
        -:  808:  for (;;)
        -:  809:  {
        -:  810:    // Try to complete the operation without blocking.
        -:  811:    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
        -:  812:
        -:  813:    // Check if operation succeeded.
        -:  814:    if (bytes > 0)
        -:  815:      return bytes;
        -:  816:
        -:  817:    // Check for EOF.
        -:  818:    if ((state & stream_oriented) && bytes == 0)
        -:  819:    {
        -:  820:      ec = boost::asio::error::eof;
        -:  821:      return 0;
        -:  822:    }
        -:  823:
        -:  824:    // Operation failed.
        -:  825:    if ((state & user_set_non_blocking)
        -:  826:        || (ec != boost::asio::error::would_block
        -:  827:          && ec != boost::asio::error::try_again))
        -:  828:      return 0;
        -:  829:
        -:  830:    // Wait for socket to become ready.
        -:  831:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  832:      return 0;
        -:  833:  }
        -:  834:}
        -:  835:
        -:  836:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  837:
        -:  838:void complete_iocp_recv(state_type state,
        -:  839:    const weak_cancel_token_type& cancel_token, bool all_empty,
        -:  840:    boost::system::error_code& ec, size_t bytes_transferred)
        -:  841:{
        -:  842:  // Map non-portable errors to their portable counterparts.
        -:  843:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  844:  {
        -:  845:    if (cancel_token.expired())
        -:  846:      ec = boost::asio::error::operation_aborted;
        -:  847:    else
        -:  848:      ec = boost::asio::error::connection_reset;
        -:  849:  }
        -:  850:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  851:  {
        -:  852:    ec = boost::asio::error::connection_refused;
        -:  853:  }
        -:  854:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  855:  {
        -:  856:    ec.assign(0, ec.category());
        -:  857:  }
        -:  858:
        -:  859:  // Check for connection closed.
        -:  860:  else if (!ec && bytes_transferred == 0
        -:  861:      && (state & stream_oriented) != 0
        -:  862:      && !all_empty)
        -:  863:  {
        -:  864:    ec = boost::asio::error::eof;
        -:  865:  }
        -:  866:}
        -:  867:
        -:  868:#else // defined(BOOST_ASIO_HAS_IOCP)
        -:  869:
        3:  870:bool non_blocking_recv(socket_type s,
        -:  871:    buffer* bufs, size_t count, int flags, bool is_stream,
        -:  872:    boost::system::error_code& ec, size_t& bytes_transferred)
        -:  873:{
        -:  874:  for (;;)
        -:  875:  {
        -:  876:    // Read some data.
        3:  877:    signed_size_type bytes = socket_ops::recv(s, bufs, count, flags, ec);
        3:  877-block  0
        -:  878:
        -:  879:    // Check for end of stream.
        3:  880:    if (is_stream && bytes == 0)
        3:  880-block  0
        -:  881:    {
    #####:  882:      ec = boost::asio::error::eof;
    %%%%%:  882-block  0
    #####:  883:      return true;
        -:  884:    }
        -:  885:
        -:  886:    // Retry operation if interrupted by signal.
       3*:  887:    if (ec == boost::asio::error::interrupted)
        3:  887-block  0
    #####:  888:      continue;
    %%%%%:  888-block  0
        -:  889:
        -:  890:    // Check if we need to run the operation again.
        3:  891:    if (ec == boost::asio::error::would_block
        3:  891-block  0
        3:  892:        || ec == boost::asio::error::try_again)
        2:  892-block  0
        1:  892-block  1
        2:  892-block  2
        3:  892-block  3
        1:  893:      return false;
        1:  893-block  0
        -:  894:
        -:  895:    // Operation is complete.
        2:  896:    if (bytes >= 0)
        2:  896-block  0
        -:  897:    {
        2:  898:      ec = boost::system::error_code();
        2:  898-block  0
        2:  899:      bytes_transferred = bytes;
        -:  900:    }
        -:  901:    else
    #####:  902:      bytes_transferred = 0;
    %%%%%:  902-block  0
        -:  903:
        2:  904:    return true;
        2:  904-block  0
    #####:  905:  }
    %%%%%:  905-block  0
        -:  906:}
        -:  907:
        -:  908:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -:  909:
        -:  910:signed_size_type recvfrom(socket_type s, buffer* bufs, size_t count,
        -:  911:    int flags, socket_addr_type* addr, std::size_t* addrlen,
        -:  912:    boost::system::error_code& ec)
        -:  913:{
        -:  914:  clear_last_error();
        -:  915:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  916:  // Receive some data.
        -:  917:  DWORD recv_buf_count = static_cast<DWORD>(count);
        -:  918:  DWORD bytes_transferred = 0;
        -:  919:  DWORD recv_flags = flags;
        -:  920:  int tmp_addrlen = (int)*addrlen;
        -:  921:  int result = error_wrapper(::WSARecvFrom(s, bufs, recv_buf_count,
        -:  922:        &bytes_transferred, &recv_flags, addr, &tmp_addrlen, 0, 0), ec);
        -:  923:  *addrlen = (std::size_t)tmp_addrlen;
        -:  924:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  925:    ec = boost::asio::error::connection_reset;
        -:  926:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  927:    ec = boost::asio::error::connection_refused;
        -:  928:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -:  929:    result = 0;
        -:  930:  if (result != 0)
        -:  931:    return socket_error_retval;
        -:  932:  ec = boost::system::error_code();
        -:  933:  return bytes_transferred;
        -:  934:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  935:  msghdr msg = msghdr();
        -:  936:  init_msghdr_msg_name(msg.msg_name, addr);
        -:  937:  msg.msg_namelen = static_cast<int>(*addrlen);
        -:  938:  msg.msg_iov = bufs;
        -:  939:  msg.msg_iovlen = static_cast<int>(count);
        -:  940:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, flags), ec);
        -:  941:  *addrlen = msg.msg_namelen;
        -:  942:  if (result >= 0)
        -:  943:    ec = boost::system::error_code();
        -:  944:  return result;
        -:  945:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  946:}
        -:  947:
        -:  948:size_t sync_recvfrom(socket_type s, state_type state, buffer* bufs,
        -:  949:    size_t count, int flags, socket_addr_type* addr,
        -:  950:    std::size_t* addrlen, boost::system::error_code& ec)
        -:  951:{
        -:  952:  if (s == invalid_socket)
        -:  953:  {
        -:  954:    ec = boost::asio::error::bad_descriptor;
        -:  955:    return 0;
        -:  956:  }
        -:  957:
        -:  958:  // Read some data.
        -:  959:  for (;;)
        -:  960:  {
        -:  961:    // Try to complete the operation without blocking.
        -:  962:    signed_size_type bytes = socket_ops::recvfrom(
        -:  963:        s, bufs, count, flags, addr, addrlen, ec);
        -:  964:
        -:  965:    // Check if operation succeeded.
        -:  966:    if (bytes >= 0)
        -:  967:      return bytes;
        -:  968:
        -:  969:    // Operation failed.
        -:  970:    if ((state & user_set_non_blocking)
        -:  971:        || (ec != boost::asio::error::would_block
        -:  972:          && ec != boost::asio::error::try_again))
        -:  973:      return 0;
        -:  974:
        -:  975:    // Wait for socket to become ready.
        -:  976:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -:  977:      return 0;
        -:  978:  }
        -:  979:}
        -:  980:
        -:  981:#if defined(BOOST_ASIO_HAS_IOCP)
        -:  982:
        -:  983:void complete_iocp_recvfrom(
        -:  984:    const weak_cancel_token_type& cancel_token,
        -:  985:    boost::system::error_code& ec)
        -:  986:{
        -:  987:  // Map non-portable errors to their portable counterparts.
        -:  988:  if (ec.value() == ERROR_NETNAME_DELETED)
        -:  989:  {
        -:  990:    if (cancel_token.expired())
        -:  991:      ec = boost::asio::error::operation_aborted;
        -:  992:    else
        -:  993:      ec = boost::asio::error::connection_reset;
        -:  994:  }
        -:  995:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -:  996:  {
        -:  997:    ec = boost::asio::error::connection_refused;
        -:  998:  }
        -:  999:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -: 1000:  {
        -: 1001:    ec.assign(0, ec.category());
        -: 1002:  }
        -: 1003:}
        -: 1004:
        -: 1005:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1006:
        -: 1007:bool non_blocking_recvfrom(socket_type s,
        -: 1008:    buffer* bufs, size_t count, int flags,
        -: 1009:    socket_addr_type* addr, std::size_t* addrlen,
        -: 1010:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1011:{
        -: 1012:  for (;;)
        -: 1013:  {
        -: 1014:    // Read some data.
        -: 1015:    signed_size_type bytes = socket_ops::recvfrom(
        -: 1016:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1017:
        -: 1018:    // Retry operation if interrupted by signal.
        -: 1019:    if (ec == boost::asio::error::interrupted)
        -: 1020:      continue;
        -: 1021:
        -: 1022:    // Check if we need to run the operation again.
        -: 1023:    if (ec == boost::asio::error::would_block
        -: 1024:        || ec == boost::asio::error::try_again)
        -: 1025:      return false;
        -: 1026:
        -: 1027:    // Operation is complete.
        -: 1028:    if (bytes >= 0)
        -: 1029:    {
        -: 1030:      ec = boost::system::error_code();
        -: 1031:      bytes_transferred = bytes;
        -: 1032:    }
        -: 1033:    else
        -: 1034:      bytes_transferred = 0;
        -: 1035:
        -: 1036:    return true;
        -: 1037:  }
        -: 1038:}
        -: 1039:
        -: 1040:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1041:
        -: 1042:signed_size_type recvmsg(socket_type s, buffer* bufs, size_t count,
        -: 1043:    int in_flags, int& out_flags, boost::system::error_code& ec)
        -: 1044:{
        -: 1045:  clear_last_error();
        -: 1046:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1047:  out_flags = 0;
        -: 1048:  return socket_ops::recv(s, bufs, count, in_flags, ec);
        -: 1049:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1050:  msghdr msg = msghdr();
        -: 1051:  msg.msg_iov = bufs;
        -: 1052:  msg.msg_iovlen = static_cast<int>(count);
        -: 1053:  signed_size_type result = error_wrapper(::recvmsg(s, &msg, in_flags), ec);
        -: 1054:  if (result >= 0)
        -: 1055:  {
        -: 1056:    ec = boost::system::error_code();
        -: 1057:    out_flags = msg.msg_flags;
        -: 1058:  }
        -: 1059:  else
        -: 1060:    out_flags = 0;
        -: 1061:  return result;
        -: 1062:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1063:}
        -: 1064:
        -: 1065:size_t sync_recvmsg(socket_type s, state_type state,
        -: 1066:    buffer* bufs, size_t count, int in_flags, int& out_flags,
        -: 1067:    boost::system::error_code& ec)
        -: 1068:{
        -: 1069:  if (s == invalid_socket)
        -: 1070:  {
        -: 1071:    ec = boost::asio::error::bad_descriptor;
        -: 1072:    return 0;
        -: 1073:  }
        -: 1074:
        -: 1075:  // Read some data.
        -: 1076:  for (;;)
        -: 1077:  {
        -: 1078:    // Try to complete the operation without blocking.
        -: 1079:    signed_size_type bytes = socket_ops::recvmsg(
        -: 1080:        s, bufs, count, in_flags, out_flags, ec);
        -: 1081:
        -: 1082:    // Check if operation succeeded.
        -: 1083:    if (bytes >= 0)
        -: 1084:      return bytes;
        -: 1085:
        -: 1086:    // Operation failed.
        -: 1087:    if ((state & user_set_non_blocking)
        -: 1088:        || (ec != boost::asio::error::would_block
        -: 1089:          && ec != boost::asio::error::try_again))
        -: 1090:      return 0;
        -: 1091:
        -: 1092:    // Wait for socket to become ready.
        -: 1093:    if (socket_ops::poll_read(s, 0, -1, ec) < 0)
        -: 1094:      return 0;
        -: 1095:  }
        -: 1096:}
        -: 1097:
        -: 1098:#if defined(BOOST_ASIO_HAS_IOCP)
        -: 1099:
        -: 1100:void complete_iocp_recvmsg(
        -: 1101:    const weak_cancel_token_type& cancel_token,
        -: 1102:    boost::system::error_code& ec)
        -: 1103:{
        -: 1104:  // Map non-portable errors to their portable counterparts.
        -: 1105:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1106:  {
        -: 1107:    if (cancel_token.expired())
        -: 1108:      ec = boost::asio::error::operation_aborted;
        -: 1109:    else
        -: 1110:      ec = boost::asio::error::connection_reset;
        -: 1111:  }
        -: 1112:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1113:  {
        -: 1114:    ec = boost::asio::error::connection_refused;
        -: 1115:  }
        -: 1116:  else if (ec.value() == WSAEMSGSIZE || ec.value() == ERROR_MORE_DATA)
        -: 1117:  {
        -: 1118:    ec.assign(0, ec.category());
        -: 1119:  }
        -: 1120:}
        -: 1121:
        -: 1122:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1123:
        -: 1124:bool non_blocking_recvmsg(socket_type s,
        -: 1125:    buffer* bufs, size_t count, int in_flags, int& out_flags,
        -: 1126:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1127:{
        -: 1128:  for (;;)
        -: 1129:  {
        -: 1130:    // Read some data.
        -: 1131:    signed_size_type bytes = socket_ops::recvmsg(
        -: 1132:        s, bufs, count, in_flags, out_flags, ec);
        -: 1133:
        -: 1134:    // Retry operation if interrupted by signal.
        -: 1135:    if (ec == boost::asio::error::interrupted)
        -: 1136:      continue;
        -: 1137:
        -: 1138:    // Check if we need to run the operation again.
        -: 1139:    if (ec == boost::asio::error::would_block
        -: 1140:        || ec == boost::asio::error::try_again)
        -: 1141:      return false;
        -: 1142:
        -: 1143:    // Operation is complete.
        -: 1144:    if (bytes >= 0)
        -: 1145:    {
        -: 1146:      ec = boost::system::error_code();
        -: 1147:      bytes_transferred = bytes;
        -: 1148:    }
        -: 1149:    else
        -: 1150:      bytes_transferred = 0;
        -: 1151:
        -: 1152:    return true;
        -: 1153:  }
        -: 1154:}
        -: 1155:
        -: 1156:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1157:
        1: 1158:signed_size_type send(socket_type s, const buffer* bufs, size_t count,
        -: 1159:    int flags, boost::system::error_code& ec)
        -: 1160:{
        1: 1161:  clear_last_error();
        1: 1161-block  0
        -: 1162:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1163:  // Send the data.
        -: 1164:  DWORD send_buf_count = static_cast<DWORD>(count);
        -: 1165:  DWORD bytes_transferred = 0;
        -: 1166:  DWORD send_flags = flags;
        -: 1167:  int result = error_wrapper(::WSASend(s, const_cast<buffer*>(bufs),
        -: 1168:        send_buf_count, &bytes_transferred, send_flags, 0, 0), ec);
        -: 1169:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1170:    ec = boost::asio::error::connection_reset;
        -: 1171:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1172:    ec = boost::asio::error::connection_refused;
        -: 1173:  if (result != 0)
        -: 1174:    return socket_error_retval;
        -: 1175:  ec = boost::system::error_code();
        -: 1176:  return bytes_transferred;
        -: 1177:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        1: 1178:  msghdr msg = msghdr();
        1: 1179:  msg.msg_iov = const_cast<buffer*>(bufs);
        1: 1180:  msg.msg_iovlen = static_cast<int>(count);
        -: 1181:#if defined(__linux__)
        1: 1182:  flags |= MSG_NOSIGNAL;
        -: 1183:#endif // defined(__linux__)
        1: 1184:  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
        1: 1184-block  0
        1: 1185:  if (result >= 0)
        1: 1186:    ec = boost::system::error_code();
        1: 1186-block  0
        1: 1187:  return result;
        1: 1187-block  0
        1: 1187-block  1
        -: 1188:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1189:}
        -: 1190:
        -: 1191:size_t sync_send(socket_type s, state_type state, const buffer* bufs,
        -: 1192:    size_t count, int flags, bool all_empty, boost::system::error_code& ec)
        -: 1193:{
        -: 1194:  if (s == invalid_socket)
        -: 1195:  {
        -: 1196:    ec = boost::asio::error::bad_descriptor;
        -: 1197:    return 0;
        -: 1198:  }
        -: 1199:
        -: 1200:  // A request to write 0 bytes to a stream is a no-op.
        -: 1201:  if (all_empty && (state & stream_oriented))
        -: 1202:  {
        -: 1203:    ec = boost::system::error_code();
        -: 1204:    return 0;
        -: 1205:  }
        -: 1206:
        -: 1207:  // Read some data.
        -: 1208:  for (;;)
        -: 1209:  {
        -: 1210:    // Try to complete the operation without blocking.
        -: 1211:    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
        -: 1212:
        -: 1213:    // Check if operation succeeded.
        -: 1214:    if (bytes >= 0)
        -: 1215:      return bytes;
        -: 1216:
        -: 1217:    // Operation failed.
        -: 1218:    if ((state & user_set_non_blocking)
        -: 1219:        || (ec != boost::asio::error::would_block
        -: 1220:          && ec != boost::asio::error::try_again))
        -: 1221:      return 0;
        -: 1222:
        -: 1223:    // Wait for socket to become ready.
        -: 1224:    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
        -: 1225:      return 0;
        -: 1226:  }
        -: 1227:}
        -: 1228:
        -: 1229:#if defined(BOOST_ASIO_HAS_IOCP)
        -: 1230:
        -: 1231:void complete_iocp_send(
        -: 1232:    const weak_cancel_token_type& cancel_token,
        -: 1233:    boost::system::error_code& ec)
        -: 1234:{
        -: 1235:  // Map non-portable errors to their portable counterparts.
        -: 1236:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1237:  {
        -: 1238:    if (cancel_token.expired())
        -: 1239:      ec = boost::asio::error::operation_aborted;
        -: 1240:    else
        -: 1241:      ec = boost::asio::error::connection_reset;
        -: 1242:  }
        -: 1243:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1244:  {
        -: 1245:    ec = boost::asio::error::connection_refused;
        -: 1246:  }
        -: 1247:}
        -: 1248:
        -: 1249:#else // defined(BOOST_ASIO_HAS_IOCP)
        -: 1250:
        1: 1251:bool non_blocking_send(socket_type s,
        -: 1252:    const buffer* bufs, size_t count, int flags,
        -: 1253:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1254:{
        -: 1255:  for (;;)
        -: 1256:  {
        -: 1257:    // Write some data.
        1: 1258:    signed_size_type bytes = socket_ops::send(s, bufs, count, flags, ec);
        1: 1258-block  0
        -: 1259:
        -: 1260:    // Retry operation if interrupted by signal.
       1*: 1261:    if (ec == boost::asio::error::interrupted)
    #####: 1262:      continue;
    %%%%%: 1262-block  0
        -: 1263:
        -: 1264:    // Check if we need to run the operation again.
        1: 1265:    if (ec == boost::asio::error::would_block
        1: 1265-block  0
       1*: 1266:        || ec == boost::asio::error::try_again)
        1: 1266-block  0
    %%%%%: 1266-block  1
        1: 1266-block  2
        1: 1266-block  3
    #####: 1267:      return false;
    %%%%%: 1267-block  0
        -: 1268:
        -: 1269:    // Operation is complete.
        1: 1270:    if (bytes >= 0)
        1: 1270-block  0
        -: 1271:    {
        1: 1272:      ec = boost::system::error_code();
        1: 1272-block  0
        1: 1273:      bytes_transferred = bytes;
        -: 1274:    }
        -: 1275:    else
    #####: 1276:      bytes_transferred = 0;
    %%%%%: 1276-block  0
        -: 1277:
        1: 1278:    return true;
        1: 1278-block  0
    #####: 1279:  }
    %%%%%: 1279-block  0
        -: 1280:}
        -: 1281:
        -: 1282:#endif // defined(BOOST_ASIO_HAS_IOCP)
        -: 1283:
        -: 1284:signed_size_type sendto(socket_type s, const buffer* bufs, size_t count,
        -: 1285:    int flags, const socket_addr_type* addr, std::size_t addrlen,
        -: 1286:    boost::system::error_code& ec)
        -: 1287:{
        -: 1288:  clear_last_error();
        -: 1289:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1290:  // Send the data.
        -: 1291:  DWORD send_buf_count = static_cast<DWORD>(count);
        -: 1292:  DWORD bytes_transferred = 0;
        -: 1293:  int result = error_wrapper(::WSASendTo(s, const_cast<buffer*>(bufs),
        -: 1294:        send_buf_count, &bytes_transferred, flags, addr,
        -: 1295:        static_cast<int>(addrlen), 0, 0), ec);
        -: 1296:  if (ec.value() == ERROR_NETNAME_DELETED)
        -: 1297:    ec = boost::asio::error::connection_reset;
        -: 1298:  else if (ec.value() == ERROR_PORT_UNREACHABLE)
        -: 1299:    ec = boost::asio::error::connection_refused;
        -: 1300:  if (result != 0)
        -: 1301:    return socket_error_retval;
        -: 1302:  ec = boost::system::error_code();
        -: 1303:  return bytes_transferred;
        -: 1304:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1305:  msghdr msg = msghdr();
        -: 1306:  init_msghdr_msg_name(msg.msg_name, addr);
        -: 1307:  msg.msg_namelen = static_cast<int>(addrlen);
        -: 1308:  msg.msg_iov = const_cast<buffer*>(bufs);
        -: 1309:  msg.msg_iovlen = static_cast<int>(count);
        -: 1310:#if defined(__linux__)
        -: 1311:  flags |= MSG_NOSIGNAL;
        -: 1312:#endif // defined(__linux__)
        -: 1313:  signed_size_type result = error_wrapper(::sendmsg(s, &msg, flags), ec);
        -: 1314:  if (result >= 0)
        -: 1315:    ec = boost::system::error_code();
        -: 1316:  return result;
        -: 1317:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1318:}
        -: 1319:
        -: 1320:size_t sync_sendto(socket_type s, state_type state, const buffer* bufs,
        -: 1321:    size_t count, int flags, const socket_addr_type* addr,
        -: 1322:    std::size_t addrlen, boost::system::error_code& ec)
        -: 1323:{
        -: 1324:  if (s == invalid_socket)
        -: 1325:  {
        -: 1326:    ec = boost::asio::error::bad_descriptor;
        -: 1327:    return 0;
        -: 1328:  }
        -: 1329:
        -: 1330:  // Write some data.
        -: 1331:  for (;;)
        -: 1332:  {
        -: 1333:    // Try to complete the operation without blocking.
        -: 1334:    signed_size_type bytes = socket_ops::sendto(
        -: 1335:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1336:
        -: 1337:    // Check if operation succeeded.
        -: 1338:    if (bytes >= 0)
        -: 1339:      return bytes;
        -: 1340:
        -: 1341:    // Operation failed.
        -: 1342:    if ((state & user_set_non_blocking)
        -: 1343:        || (ec != boost::asio::error::would_block
        -: 1344:          && ec != boost::asio::error::try_again))
        -: 1345:      return 0;
        -: 1346:
        -: 1347:    // Wait for socket to become ready.
        -: 1348:    if (socket_ops::poll_write(s, 0, -1, ec) < 0)
        -: 1349:      return 0;
        -: 1350:  }
        -: 1351:}
        -: 1352:
        -: 1353:#if !defined(BOOST_ASIO_HAS_IOCP)
        -: 1354:
        -: 1355:bool non_blocking_sendto(socket_type s,
        -: 1356:    const buffer* bufs, size_t count, int flags,
        -: 1357:    const socket_addr_type* addr, std::size_t addrlen,
        -: 1358:    boost::system::error_code& ec, size_t& bytes_transferred)
        -: 1359:{
        -: 1360:  for (;;)
        -: 1361:  {
        -: 1362:    // Write some data.
        -: 1363:    signed_size_type bytes = socket_ops::sendto(
        -: 1364:        s, bufs, count, flags, addr, addrlen, ec);
        -: 1365:
        -: 1366:    // Retry operation if interrupted by signal.
        -: 1367:    if (ec == boost::asio::error::interrupted)
        -: 1368:      continue;
        -: 1369:
        -: 1370:    // Check if we need to run the operation again.
        -: 1371:    if (ec == boost::asio::error::would_block
        -: 1372:        || ec == boost::asio::error::try_again)
        -: 1373:      return false;
        -: 1374:
        -: 1375:    // Operation is complete.
        -: 1376:    if (bytes >= 0)
        -: 1377:    {
        -: 1378:      ec = boost::system::error_code();
        -: 1379:      bytes_transferred = bytes;
        -: 1380:    }
        -: 1381:    else
        -: 1382:      bytes_transferred = 0;
        -: 1383:
        -: 1384:    return true;
        -: 1385:  }
        -: 1386:}
        -: 1387:
        -: 1388:#endif // !defined(BOOST_ASIO_HAS_IOCP)
        -: 1389:
        1: 1390:socket_type socket(int af, int type, int protocol,
        -: 1391:    boost::system::error_code& ec)
        -: 1392:{
        1: 1393:  clear_last_error();
        1: 1393-block  0
        -: 1394:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1395:  socket_type s = error_wrapper(::WSASocketW(af, type, protocol, 0, 0,
        -: 1396:        WSA_FLAG_OVERLAPPED), ec);
        -: 1397:  if (s == invalid_socket)
        -: 1398:    return s;
        -: 1399:
        -: 1400:  if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 1401:  {
        -: 1402:    // Try to enable the POSIX default behaviour of having IPV6_V6ONLY set to
        -: 1403:    // false. This will only succeed on Windows Vista and later versions of
        -: 1404:    // Windows, where a dual-stack IPv4/v6 implementation is available.
        -: 1405:    DWORD optval = 0;
        -: 1406:    ::setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
        -: 1407:        reinterpret_cast<const char*>(&optval), sizeof(optval));
        -: 1408:  }
        -: 1409:
        -: 1410:  ec = boost::system::error_code();
        -: 1411:
        -: 1412:  return s;
        -: 1413:#elif defined(__MACH__) && defined(__APPLE__) || defined(__FreeBSD__)
        -: 1414:  socket_type s = error_wrapper(::socket(af, type, protocol), ec);
        -: 1415:  if (s == invalid_socket)
        -: 1416:    return s;
        -: 1417:
        -: 1418:  int optval = 1;
        -: 1419:  int result = error_wrapper(::setsockopt(s,
        -: 1420:        SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval)), ec);
        -: 1421:  if (result != 0)
        -: 1422:  {
        -: 1423:    ::close(s);
        -: 1424:    return invalid_socket;
        -: 1425:  }
        -: 1426:
        -: 1427:  return s;
        -: 1428:#else
        1: 1429:  int s = error_wrapper(::socket(af, type, protocol), ec);
        1: 1430:  if (s >= 0)
        1: 1431:    ec = boost::system::error_code();
        1: 1431-block  0
        1: 1432:  return s;
        1: 1432-block  0
        -: 1433:#endif
        -: 1434:}
        -: 1435:
        -: 1436:template <typename SockLenType>
    #####: 1437:inline int call_setsockopt(SockLenType msghdr::*,
        -: 1438:    socket_type s, int level, int optname,
        -: 1439:    const void* optval, std::size_t optlen)
        -: 1440:{
    #####: 1441:  return ::setsockopt(s, level, optname,
    %%%%%: 1441-block  0
    #####: 1442:      (const char*)optval, (SockLenType)optlen);
        -: 1443:}
        -: 1444:
    #####: 1445:int setsockopt(socket_type s, state_type& state, int level, int optname,
        -: 1446:    const void* optval, std::size_t optlen, boost::system::error_code& ec)
        -: 1447:{
    #####: 1448:  if (s == invalid_socket)
    %%%%%: 1448-block  0
        -: 1449:  {
    #####: 1450:    ec = boost::asio::error::bad_descriptor;
    %%%%%: 1450-block  0
    #####: 1451:    return socket_error_retval;
        -: 1452:  }
        -: 1453:
    #####: 1454:  if (level == custom_socket_option_level && optname == always_fail_option)
    %%%%%: 1454-block  0
    %%%%%: 1454-block  1
        -: 1455:  {
    #####: 1456:    ec = boost::asio::error::invalid_argument;
    %%%%%: 1456-block  0
    #####: 1457:    return socket_error_retval;
        -: 1458:  }
        -: 1459:
    #####: 1460:  if (level == custom_socket_option_level
    %%%%%: 1460-block  0
    #####: 1461:      && optname == enable_connection_aborted_option)
    %%%%%: 1461-block  0
        -: 1462:  {
    #####: 1463:    if (optlen != sizeof(int))
    %%%%%: 1463-block  0
        -: 1464:    {
    #####: 1465:      ec = boost::asio::error::invalid_argument;
    %%%%%: 1465-block  0
    #####: 1466:      return socket_error_retval;
        -: 1467:    }
        -: 1468:
    #####: 1469:    if (*static_cast<const int*>(optval))
    %%%%%: 1469-block  0
    #####: 1470:      state |= enable_connection_aborted;
    %%%%%: 1470-block  0
        -: 1471:    else
    #####: 1472:      state &= ~enable_connection_aborted;
    %%%%%: 1472-block  0
    #####: 1473:    ec = boost::system::error_code();
    %%%%%: 1473-block  0
    #####: 1474:    return 0;
        -: 1475:  }
        -: 1476:
    #####: 1477:  if (level == SOL_SOCKET && optname == SO_LINGER)
    %%%%%: 1477-block  0
    %%%%%: 1477-block  1
    #####: 1478:    state |= user_set_linger;
    %%%%%: 1478-block  0
        -: 1479:
        -: 1480:#if defined(__BORLANDC__)
        -: 1481:  // Mysteriously, using the getsockopt and setsockopt functions directly with
        -: 1482:  // Borland C++ results in incorrect values being set and read. The bug can be
        -: 1483:  // worked around by using function addresses resolved with GetProcAddress.
        -: 1484:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 1485:  {
        -: 1486:    typedef int (WSAAPI *sso_t)(SOCKET, int, int, const char*, int);
        -: 1487:    if (sso_t sso = (sso_t)::GetProcAddress(winsock_module, "setsockopt"))
        -: 1488:    {
        -: 1489:      clear_last_error();
        -: 1490:      return error_wrapper(sso(s, level, optname,
        -: 1491:            reinterpret_cast<const char*>(optval),
        -: 1492:            static_cast<int>(optlen)), ec);
        -: 1493:    }
        -: 1494:  }
        -: 1495:  ec = boost::asio::error::fault;
        -: 1496:  return socket_error_retval;
        -: 1497:#else // defined(__BORLANDC__)
    #####: 1498:  clear_last_error();
    %%%%%: 1498-block  0
    #####: 1499:  int result = error_wrapper(call_setsockopt(&msghdr::msg_namelen,
        -: 1500:        s, level, optname, optval, optlen), ec);
    #####: 1501:  if (result == 0)
        -: 1502:  {
    #####: 1503:    ec = boost::system::error_code();
    %%%%%: 1503-block  0
        -: 1504:
        -: 1505:#if defined(__MACH__) && defined(__APPLE__) \
        -: 1506:  || defined(__NetBSD__) || defined(__FreeBSD__) \
        -: 1507:  || defined(__OpenBSD__) || defined(__QNX__)
        -: 1508:    // To implement portable behaviour for SO_REUSEADDR with UDP sockets we
        -: 1509:    // need to also set SO_REUSEPORT on BSD-based platforms.
        -: 1510:    if ((state & datagram_oriented)
        -: 1511:        && level == SOL_SOCKET && optname == SO_REUSEADDR)
        -: 1512:    {
        -: 1513:      call_setsockopt(&msghdr::msg_namelen, s,
        -: 1514:          SOL_SOCKET, SO_REUSEPORT, optval, optlen);
        -: 1515:    }
        -: 1516:#endif
        -: 1517:  }
        -: 1518:
    #####: 1519:  return result;
    %%%%%: 1519-block  0
        -: 1520:#endif // defined(__BORLANDC__)
        -: 1521:}
        -: 1522:
        -: 1523:template <typename SockLenType>
        1: 1524:inline int call_getsockopt(SockLenType msghdr::*,
        -: 1525:    socket_type s, int level, int optname,
        -: 1526:    void* optval, std::size_t* optlen)
        -: 1527:{
        1: 1528:  SockLenType tmp_optlen = (SockLenType)*optlen;
        1: 1529:  int result = ::getsockopt(s, level, optname, (char*)optval, &tmp_optlen);
        1: 1529-block  0
        1: 1530:  *optlen = (std::size_t)tmp_optlen;
        1: 1531:  return result;
        -: 1532:}
        -: 1533:
        1: 1534:int getsockopt(socket_type s, state_type state, int level, int optname,
        -: 1535:    void* optval, size_t* optlen, boost::system::error_code& ec)
        -: 1536:{
        1: 1537:  if (s == invalid_socket)
        1: 1537-block  0
        -: 1538:  {
    #####: 1539:    ec = boost::asio::error::bad_descriptor;
    %%%%%: 1539-block  0
    #####: 1540:    return socket_error_retval;
        -: 1541:  }
        -: 1542:
       1*: 1543:  if (level == custom_socket_option_level && optname == always_fail_option)
        1: 1543-block  0
    %%%%%: 1543-block  1
        -: 1544:  {
    #####: 1545:    ec = boost::asio::error::invalid_argument;
    %%%%%: 1545-block  0
    #####: 1546:    return socket_error_retval;
        -: 1547:  }
        -: 1548:
        1: 1549:  if (level == custom_socket_option_level
        1: 1549-block  0
    #####: 1550:      && optname == enable_connection_aborted_option)
    %%%%%: 1550-block  0
        -: 1551:  {
    #####: 1552:    if (*optlen != sizeof(int))
    %%%%%: 1552-block  0
        -: 1553:    {
    #####: 1554:      ec = boost::asio::error::invalid_argument;
    %%%%%: 1554-block  0
    #####: 1555:      return socket_error_retval;
        -: 1556:    }
        -: 1557:
    #####: 1558:    *static_cast<int*>(optval) = (state & enable_connection_aborted) ? 1 : 0;
    #####: 1559:    ec = boost::system::error_code();
    %%%%%: 1559-block  0
    #####: 1560:    return 0;
        -: 1561:  }
        -: 1562:
        -: 1563:#if defined(__BORLANDC__)
        -: 1564:  // Mysteriously, using the getsockopt and setsockopt functions directly with
        -: 1565:  // Borland C++ results in incorrect values being set and read. The bug can be
        -: 1566:  // worked around by using function addresses resolved with GetProcAddress.
        -: 1567:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 1568:  {
        -: 1569:    typedef int (WSAAPI *gso_t)(SOCKET, int, int, char*, int*);
        -: 1570:    if (gso_t gso = (gso_t)::GetProcAddress(winsock_module, "getsockopt"))
        -: 1571:    {
        -: 1572:      clear_last_error();
        -: 1573:      int tmp_optlen = static_cast<int>(*optlen);
        -: 1574:      int result = error_wrapper(gso(s, level, optname,
        -: 1575:            reinterpret_cast<char*>(optval), &tmp_optlen), ec);
        -: 1576:      *optlen = static_cast<size_t>(tmp_optlen);
        -: 1577:      if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
        -: 1578:          && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
        -: 1579:      {
        -: 1580:        // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are
        -: 1581:        // only supported on Windows Vista and later. To simplify program logic
        -: 1582:        // we will fake success of getting this option and specify that the
        -: 1583:        // value is non-zero (i.e. true). This corresponds to the behavior of
        -: 1584:        // IPv6 sockets on Windows platforms pre-Vista.
        -: 1585:        *static_cast<DWORD*>(optval) = 1;
        -: 1586:        ec = boost::system::error_code();
        -: 1587:      }
        -: 1588:      return result;
        -: 1589:    }
        -: 1590:  }
        -: 1591:  ec = boost::asio::error::fault;
        -: 1592:  return socket_error_retval;
        -: 1593:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1594:  clear_last_error();
        -: 1595:  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
        -: 1596:        s, level, optname, optval, optlen), ec);
        -: 1597:  if (result != 0 && level == IPPROTO_IPV6 && optname == IPV6_V6ONLY
        -: 1598:      && ec.value() == WSAENOPROTOOPT && *optlen == sizeof(DWORD))
        -: 1599:  {
        -: 1600:    // Dual-stack IPv4/v6 sockets, and the IPV6_V6ONLY socket option, are only
        -: 1601:    // supported on Windows Vista and later. To simplify program logic we will
        -: 1602:    // fake success of getting this option and specify that the value is
        -: 1603:    // non-zero (i.e. true). This corresponds to the behavior of IPv6 sockets
        -: 1604:    // on Windows platforms pre-Vista.
        -: 1605:    *static_cast<DWORD*>(optval) = 1;
        -: 1606:    ec = boost::system::error_code();
        -: 1607:  }
        -: 1608:  if (result == 0)
        -: 1609:    ec = boost::system::error_code();
        -: 1610:  return result;
        -: 1611:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        1: 1612:  clear_last_error();
        1: 1612-block  0
        1: 1613:  int result = error_wrapper(call_getsockopt(&msghdr::msg_namelen,
        -: 1614:        s, level, optname, optval, optlen), ec);
        -: 1615:#if defined(__linux__)
        1: 1616:  if (result == 0 && level == SOL_SOCKET && *optlen == sizeof(int)
        1: 1616-block  0
        1: 1616-block  1
        1: 1617:      && (optname == SO_SNDBUF || optname == SO_RCVBUF))
        1: 1617-block  0
        1: 1617-block  1
        -: 1618:  {
        -: 1619:    // On Linux, setting SO_SNDBUF or SO_RCVBUF to N actually causes the kernel
        -: 1620:    // to set the buffer size to N*2. Linux puts additional stuff into the
        -: 1621:    // buffers so that only about half is actually available to the application.
        -: 1622:    // The retrieved value is divided by 2 here to make it appear as though the
        -: 1623:    // correct value has been set.
    #####: 1624:    *static_cast<int*>(optval) /= 2;
    %%%%%: 1624-block  0
        -: 1625:  }
        -: 1626:#endif // defined(__linux__)
        1: 1627:  if (result == 0)
        1: 1627-block  0
        1: 1628:    ec = boost::system::error_code();
        1: 1628-block  0
        1: 1629:  return result;
        1: 1629-block  0
        -: 1630:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1631:}
        -: 1632:
        -: 1633:template <typename SockLenType>
        -: 1634:inline int call_getpeername(SockLenType msghdr::*,
        -: 1635:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -: 1636:{
        -: 1637:  SockLenType tmp_addrlen = (SockLenType)*addrlen;
        -: 1638:  int result = ::getpeername(s, addr, &tmp_addrlen);
        -: 1639:  *addrlen = (std::size_t)tmp_addrlen;
        -: 1640:  return result;
        -: 1641:}
        -: 1642:
        -: 1643:int getpeername(socket_type s, socket_addr_type* addr,
        -: 1644:    std::size_t* addrlen, bool cached, boost::system::error_code& ec)
        -: 1645:{
        -: 1646:  if (s == invalid_socket)
        -: 1647:  {
        -: 1648:    ec = boost::asio::error::bad_descriptor;
        -: 1649:    return socket_error_retval;
        -: 1650:  }
        -: 1651:
        -: 1652:#if defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP) \
        -: 1653:  || defined(__CYGWIN__)
        -: 1654:  if (cached)
        -: 1655:  {
        -: 1656:    // Check if socket is still connected.
        -: 1657:    DWORD connect_time = 0;
        -: 1658:    size_t connect_time_len = sizeof(connect_time);
        -: 1659:    if (socket_ops::getsockopt(s, 0, SOL_SOCKET, SO_CONNECT_TIME,
        -: 1660:          &connect_time, &connect_time_len, ec) == socket_error_retval)
        -: 1661:    {
        -: 1662:      return socket_error_retval;
        -: 1663:    }
        -: 1664:    if (connect_time == 0xFFFFFFFF)
        -: 1665:    {
        -: 1666:      ec = boost::asio::error::not_connected;
        -: 1667:      return socket_error_retval;
        -: 1668:    }
        -: 1669:
        -: 1670:    // The cached value is still valid.
        -: 1671:    ec = boost::system::error_code();
        -: 1672:    return 0;
        -: 1673:  }
        -: 1674:#else // defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP)
        -: 1675:      // || defined(__CYGWIN__)
        -: 1676:  (void)cached;
        -: 1677:#endif // defined(BOOST_ASIO_WINDOWS) && !defined(BOOST_ASIO_WINDOWS_APP)
        -: 1678:       // || defined(__CYGWIN__)
        -: 1679:
        -: 1680:  clear_last_error();
        -: 1681:  int result = error_wrapper(call_getpeername(
        -: 1682:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -: 1683:  if (result == 0)
        -: 1684:    ec = boost::system::error_code();
        -: 1685:  return result;
        -: 1686:}
        -: 1687:
        -: 1688:template <typename SockLenType>
        -: 1689:inline int call_getsockname(SockLenType msghdr::*,
        -: 1690:    socket_type s, socket_addr_type* addr, std::size_t* addrlen)
        -: 1691:{
        -: 1692:  SockLenType tmp_addrlen = (SockLenType)*addrlen;
        -: 1693:  int result = ::getsockname(s, addr, &tmp_addrlen);
        -: 1694:  *addrlen = (std::size_t)tmp_addrlen;
        -: 1695:  return result;
        -: 1696:}
        -: 1697:
        -: 1698:int getsockname(socket_type s, socket_addr_type* addr,
        -: 1699:    std::size_t* addrlen, boost::system::error_code& ec)
        -: 1700:{
        -: 1701:  if (s == invalid_socket)
        -: 1702:  {
        -: 1703:    ec = boost::asio::error::bad_descriptor;
        -: 1704:    return socket_error_retval;
        -: 1705:  }
        -: 1706:
        -: 1707:  clear_last_error();
        -: 1708:  int result = error_wrapper(call_getsockname(
        -: 1709:        &msghdr::msg_namelen, s, addr, addrlen), ec);
        -: 1710:  if (result == 0)
        -: 1711:    ec = boost::system::error_code();
        -: 1712:  return result;
        -: 1713:}
        -: 1714:
        -: 1715:int ioctl(socket_type s, state_type& state, int cmd,
        -: 1716:    ioctl_arg_type* arg, boost::system::error_code& ec)
        -: 1717:{
        -: 1718:  if (s == invalid_socket)
        -: 1719:  {
        -: 1720:    ec = boost::asio::error::bad_descriptor;
        -: 1721:    return socket_error_retval;
        -: 1722:  }
        -: 1723:
        -: 1724:  clear_last_error();
        -: 1725:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1726:  int result = error_wrapper(::ioctlsocket(s, cmd, arg), ec);
        -: 1727:#elif defined(__MACH__) && defined(__APPLE__) \
        -: 1728:  || defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__)
        -: 1729:  int result = error_wrapper(::ioctl(s,
        -: 1730:        static_cast<unsigned int>(cmd), arg), ec);
        -: 1731:#else
        -: 1732:  int result = error_wrapper(::ioctl(s, cmd, arg), ec);
        -: 1733:#endif
        -: 1734:  if (result >= 0)
        -: 1735:  {
        -: 1736:    ec = boost::system::error_code();
        -: 1737:
        -: 1738:    // When updating the non-blocking mode we always perform the ioctl syscall,
        -: 1739:    // even if the flags would otherwise indicate that the socket is already in
        -: 1740:    // the correct state. This ensures that the underlying socket is put into
        -: 1741:    // the state that has been requested by the user. If the ioctl syscall was
        -: 1742:    // successful then we need to update the flags to match.
        -: 1743:    if (cmd == static_cast<int>(FIONBIO))
        -: 1744:    {
        -: 1745:      if (*arg)
        -: 1746:      {
        -: 1747:        state |= user_set_non_blocking;
        -: 1748:      }
        -: 1749:      else
        -: 1750:      {
        -: 1751:        // Clearing the non-blocking mode always overrides any internally-set
        -: 1752:        // non-blocking flag. Any subsequent asynchronous operations will need
        -: 1753:        // to re-enable non-blocking I/O.
        -: 1754:        state &= ~(user_set_non_blocking | internal_non_blocking);
        -: 1755:      }
        -: 1756:    }
        -: 1757:  }
        -: 1758:
        -: 1759:  return result;
        -: 1760:}
        -: 1761:
        -: 1762:int select(int nfds, fd_set* readfds, fd_set* writefds,
        -: 1763:    fd_set* exceptfds, timeval* timeout, boost::system::error_code& ec)
        -: 1764:{
        -: 1765:  clear_last_error();
        -: 1766:#if defined(__EMSCRIPTEN__)
        -: 1767:  exceptfds = 0;
        -: 1768:#endif // defined(__EMSCRIPTEN__)
        -: 1769:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1770:  if (!readfds && !writefds && !exceptfds && timeout)
        -: 1771:  {
        -: 1772:    DWORD milliseconds = timeout->tv_sec * 1000 + timeout->tv_usec / 1000;
        -: 1773:    if (milliseconds == 0)
        -: 1774:      milliseconds = 1; // Force context switch.
        -: 1775:    ::Sleep(milliseconds);
        -: 1776:    ec = boost::system::error_code();
        -: 1777:    return 0;
        -: 1778:  }
        -: 1779:
        -: 1780:  // The select() call allows timeout values measured in microseconds, but the
        -: 1781:  // system clock (as wrapped by boost::posix_time::microsec_clock) typically
        -: 1782:  // has a resolution of 10 milliseconds. This can lead to a spinning select
        -: 1783:  // reactor, meaning increased CPU usage, when waiting for the earliest
        -: 1784:  // scheduled timeout if it's less than 10 milliseconds away. To avoid a tight
        -: 1785:  // spin we'll use a minimum timeout of 1 millisecond.
        -: 1786:  if (timeout && timeout->tv_sec == 0
        -: 1787:      && timeout->tv_usec > 0 && timeout->tv_usec < 1000)
        -: 1788:    timeout->tv_usec = 1000;
        -: 1789:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 1790:
        -: 1791:#if defined(__hpux) && defined(__SELECT)
        -: 1792:  timespec ts;
        -: 1793:  ts.tv_sec = timeout ? timeout->tv_sec : 0;
        -: 1794:  ts.tv_nsec = timeout ? timeout->tv_usec * 1000 : 0;
        -: 1795:  return error_wrapper(::pselect(nfds, readfds,
        -: 1796:        writefds, exceptfds, timeout ? &ts : 0, 0), ec);
        -: 1797:#else
        -: 1798:  int result = error_wrapper(::select(nfds, readfds,
        -: 1799:        writefds, exceptfds, timeout), ec);
        -: 1800:  if (result >= 0)
        -: 1801:    ec = boost::system::error_code();
        -: 1802:  return result;
        -: 1803:#endif
        -: 1804:}
        -: 1805:
        -: 1806:int poll_read(socket_type s, state_type state,
        -: 1807:    int msec, boost::system::error_code& ec)
        -: 1808:{
        -: 1809:  if (s == invalid_socket)
        -: 1810:  {
        -: 1811:    ec = boost::asio::error::bad_descriptor;
        -: 1812:    return socket_error_retval;
        -: 1813:  }
        -: 1814:
        -: 1815:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1816:  || defined(__CYGWIN__) \
        -: 1817:  || defined(__SYMBIAN32__)
        -: 1818:  fd_set fds;
        -: 1819:  FD_ZERO(&fds);
        -: 1820:  FD_SET(s, &fds);
        -: 1821:  timeval timeout_obj;
        -: 1822:  timeval* timeout;
        -: 1823:  if (state & user_set_non_blocking)
        -: 1824:  {
        -: 1825:    timeout_obj.tv_sec = 0;
        -: 1826:    timeout_obj.tv_usec = 0;
        -: 1827:    timeout = &timeout_obj;
        -: 1828:  }
        -: 1829:  else if (msec >= 0)
        -: 1830:  {
        -: 1831:    timeout_obj.tv_sec = msec / 1000;
        -: 1832:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1833:    timeout = &timeout_obj;
        -: 1834:  }
        -: 1835:  else
        -: 1836:    timeout = 0;
        -: 1837:  clear_last_error();
        -: 1838:  int result = error_wrapper(::select(s + 1, &fds, 0, 0, timeout), ec);
        -: 1839:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1840:      // || defined(__CYGWIN__)
        -: 1841:      // || defined(__SYMBIAN32__)
        -: 1842:  pollfd fds;
        -: 1843:  fds.fd = s;
        -: 1844:  fds.events = POLLIN;
        -: 1845:  fds.revents = 0;
        -: 1846:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1847:  clear_last_error();
        -: 1848:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1849:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1850:       // || defined(__CYGWIN__)
        -: 1851:       // || defined(__SYMBIAN32__)
        -: 1852:  if (result == 0)
        -: 1853:    ec = (state & user_set_non_blocking)
        -: 1854:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1855:  else if (result > 0)
        -: 1856:    ec = boost::system::error_code();
        -: 1857:  return result;
        -: 1858:}
        -: 1859:
        -: 1860:int poll_write(socket_type s, state_type state,
        -: 1861:    int msec, boost::system::error_code& ec)
        -: 1862:{
        -: 1863:  if (s == invalid_socket)
        -: 1864:  {
        -: 1865:    ec = boost::asio::error::bad_descriptor;
        -: 1866:    return socket_error_retval;
        -: 1867:  }
        -: 1868:
        -: 1869:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1870:  || defined(__CYGWIN__) \
        -: 1871:  || defined(__SYMBIAN32__)
        -: 1872:  fd_set fds;
        -: 1873:  FD_ZERO(&fds);
        -: 1874:  FD_SET(s, &fds);
        -: 1875:  timeval timeout_obj;
        -: 1876:  timeval* timeout;
        -: 1877:  if (state & user_set_non_blocking)
        -: 1878:  {
        -: 1879:    timeout_obj.tv_sec = 0;
        -: 1880:    timeout_obj.tv_usec = 0;
        -: 1881:    timeout = &timeout_obj;
        -: 1882:  }
        -: 1883:  else if (msec >= 0)
        -: 1884:  {
        -: 1885:    timeout_obj.tv_sec = msec / 1000;
        -: 1886:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1887:    timeout = &timeout_obj;
        -: 1888:  }
        -: 1889:  else
        -: 1890:    timeout = 0;
        -: 1891:  clear_last_error();
        -: 1892:  int result = error_wrapper(::select(s + 1, 0, &fds, 0, timeout), ec);
        -: 1893:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1894:      // || defined(__CYGWIN__)
        -: 1895:      // || defined(__SYMBIAN32__)
        -: 1896:  pollfd fds;
        -: 1897:  fds.fd = s;
        -: 1898:  fds.events = POLLOUT;
        -: 1899:  fds.revents = 0;
        -: 1900:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1901:  clear_last_error();
        -: 1902:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1903:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1904:       // || defined(__CYGWIN__)
        -: 1905:       // || defined(__SYMBIAN32__)
        -: 1906:  if (result == 0)
        -: 1907:    ec = (state & user_set_non_blocking)
        -: 1908:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1909:  else if (result > 0)
        -: 1910:    ec = boost::system::error_code();
        -: 1911:  return result;
        -: 1912:}
        -: 1913:
        -: 1914:int poll_error(socket_type s, state_type state,
        -: 1915:    int msec, boost::system::error_code& ec)
        -: 1916:{
        -: 1917:  if (s == invalid_socket)
        -: 1918:  {
        -: 1919:    ec = boost::asio::error::bad_descriptor;
        -: 1920:    return socket_error_retval;
        -: 1921:  }
        -: 1922:
        -: 1923:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1924:  || defined(__CYGWIN__) \
        -: 1925:  || defined(__SYMBIAN32__)
        -: 1926:  fd_set fds;
        -: 1927:  FD_ZERO(&fds);
        -: 1928:  FD_SET(s, &fds);
        -: 1929:  timeval timeout_obj;
        -: 1930:  timeval* timeout;
        -: 1931:  if (state & user_set_non_blocking)
        -: 1932:  {
        -: 1933:    timeout_obj.tv_sec = 0;
        -: 1934:    timeout_obj.tv_usec = 0;
        -: 1935:    timeout = &timeout_obj;
        -: 1936:  }
        -: 1937:  else if (msec >= 0)
        -: 1938:  {
        -: 1939:    timeout_obj.tv_sec = msec / 1000;
        -: 1940:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1941:    timeout = &timeout_obj;
        -: 1942:  }
        -: 1943:  else
        -: 1944:    timeout = 0;
        -: 1945:  clear_last_error();
        -: 1946:  int result = error_wrapper(::select(s + 1, 0, 0, &fds, timeout), ec);
        -: 1947:#else // defined(BOOST_ASIO_WINDOWS)
        -: 1948:      // || defined(__CYGWIN__)
        -: 1949:      // || defined(__SYMBIAN32__)
        -: 1950:  pollfd fds;
        -: 1951:  fds.fd = s;
        -: 1952:  fds.events = POLLPRI | POLLERR | POLLHUP;
        -: 1953:  fds.revents = 0;
        -: 1954:  int timeout = (state & user_set_non_blocking) ? 0 : msec;
        -: 1955:  clear_last_error();
        -: 1956:  int result = error_wrapper(::poll(&fds, 1, timeout), ec);
        -: 1957:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 1958:       // || defined(__CYGWIN__)
        -: 1959:       // || defined(__SYMBIAN32__)
        -: 1960:  if (result == 0)
        -: 1961:    ec = (state & user_set_non_blocking)
        -: 1962:      ? boost::asio::error::would_block : boost::system::error_code();
        -: 1963:  else if (result > 0)
        -: 1964:    ec = boost::system::error_code();
        -: 1965:  return result;
        -: 1966:}
        -: 1967:
        -: 1968:int poll_connect(socket_type s, int msec, boost::system::error_code& ec)
        -: 1969:{
        -: 1970:  if (s == invalid_socket)
        -: 1971:  {
        -: 1972:    ec = boost::asio::error::bad_descriptor;
        -: 1973:    return socket_error_retval;
        -: 1974:  }
        -: 1975:
        -: 1976:#if defined(BOOST_ASIO_WINDOWS) \
        -: 1977:  || defined(__CYGWIN__) \
        -: 1978:  || defined(__SYMBIAN32__)
        -: 1979:  fd_set write_fds;
        -: 1980:  FD_ZERO(&write_fds);
        -: 1981:  FD_SET(s, &write_fds);
        -: 1982:  fd_set except_fds;
        -: 1983:  FD_ZERO(&except_fds);
        -: 1984:  FD_SET(s, &except_fds);
        -: 1985:  timeval timeout_obj;
        -: 1986:  timeval* timeout;
        -: 1987:  if (msec >= 0)
        -: 1988:  {
        -: 1989:    timeout_obj.tv_sec = msec / 1000;
        -: 1990:    timeout_obj.tv_usec = (msec % 1000) * 1000;
        -: 1991:    timeout = &timeout_obj;
        -: 1992:  }
        -: 1993:  else
        -: 1994:    timeout = 0;
        -: 1995:  clear_last_error();
        -: 1996:  int result = error_wrapper(::select(
        -: 1997:        s + 1, 0, &write_fds, &except_fds, timeout), ec);
        -: 1998:  if (result >= 0)
        -: 1999:    ec = boost::system::error_code();
        -: 2000:  return result;
        -: 2001:#else // defined(BOOST_ASIO_WINDOWS)
        -: 2002:      // || defined(__CYGWIN__)
        -: 2003:      // || defined(__SYMBIAN32__)
        -: 2004:  pollfd fds;
        -: 2005:  fds.fd = s;
        -: 2006:  fds.events = POLLOUT;
        -: 2007:  fds.revents = 0;
        -: 2008:  clear_last_error();
        -: 2009:  int result = error_wrapper(::poll(&fds, 1, msec), ec);
        -: 2010:  if (result >= 0)
        -: 2011:    ec = boost::system::error_code();
        -: 2012:  return result;
        -: 2013:#endif // defined(BOOST_ASIO_WINDOWS)
        -: 2014:       // || defined(__CYGWIN__)
        -: 2015:       // || defined(__SYMBIAN32__)
        -: 2016:}
        -: 2017:
        -: 2018:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2019:
        -: 2020:const char* inet_ntop(int af, const void* src, char* dest, size_t length,
        -: 2021:    unsigned long scope_id, boost::system::error_code& ec)
        -: 2022:{
        -: 2023:  clear_last_error();
        -: 2024:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2025:  using namespace std; // For sprintf.
        -: 2026:  const unsigned char* bytes = static_cast<const unsigned char*>(src);
        -: 2027:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2028:  {
        -: 2029:    sprintf_s(dest, length, "%u.%u.%u.%u",
        -: 2030:        bytes[0], bytes[1], bytes[2], bytes[3]);
        -: 2031:    return dest;
        -: 2032:  }
        -: 2033:  else if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2034:  {
        -: 2035:    size_t n = 0, b = 0, z = 0;
        -: 2036:    while (n < length && b < 16)
        -: 2037:    {
        -: 2038:      if (bytes[b] == 0 && bytes[b + 1] == 0 && z == 0)
        -: 2039:      {
        -: 2040:        do b += 2; while (b < 16 && bytes[b] == 0 && bytes[b + 1] == 0);
        -: 2041:        n += sprintf_s(dest + n, length - n, ":%s", b < 16 ? "" : ":"), ++z;
        -: 2042:      }
        -: 2043:      else
        -: 2044:      {
        -: 2045:        n += sprintf_s(dest + n, length - n, "%s%x", b ? ":" : "",
        -: 2046:            (static_cast<u_long_type>(bytes[b]) << 8) | bytes[b + 1]);
        -: 2047:        b += 2;
        -: 2048:      }
        -: 2049:    }
        -: 2050:    if (scope_id)
        -: 2051:      n += sprintf_s(dest + n, length - n, "%%%lu", scope_id);
        -: 2052:    return dest;
        -: 2053:  }
        -: 2054:  else
        -: 2055:  {
        -: 2056:    ec = boost::asio::error::address_family_not_supported;
        -: 2057:    return 0;
        -: 2058:  }
        -: 2059:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2060:  using namespace std; // For memcpy.
        -: 2061:
        -: 2062:  if (af != BOOST_ASIO_OS_DEF(AF_INET) && af != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2063:  {
        -: 2064:    ec = boost::asio::error::address_family_not_supported;
        -: 2065:    return 0;
        -: 2066:  }
        -: 2067:
        -: 2068:  union
        -: 2069:  {
        -: 2070:    socket_addr_type base;
        -: 2071:    sockaddr_storage_type storage;
        -: 2072:    sockaddr_in4_type v4;
        -: 2073:    sockaddr_in6_type v6;
        -: 2074:  } address;
        -: 2075:  DWORD address_length;
        -: 2076:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2077:  {
        -: 2078:    address_length = sizeof(sockaddr_in4_type);
        -: 2079:    address.v4.sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2080:    address.v4.sin_port = 0;
        -: 2081:    memcpy(&address.v4.sin_addr, src, sizeof(in4_addr_type));
        -: 2082:  }
        -: 2083:  else // AF_INET6
        -: 2084:  {
        -: 2085:    address_length = sizeof(sockaddr_in6_type);
        -: 2086:    address.v6.sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2087:    address.v6.sin6_port = 0;
        -: 2088:    address.v6.sin6_flowinfo = 0;
        -: 2089:    address.v6.sin6_scope_id = scope_id;
        -: 2090:    memcpy(&address.v6.sin6_addr, src, sizeof(in6_addr_type));
        -: 2091:  }
        -: 2092:
        -: 2093:  DWORD string_length = static_cast<DWORD>(length);
        -: 2094:#if defined(BOOST_NO_ANSI_APIS) || (defined(_MSC_VER) && (_MSC_VER >= 1800))
        -: 2095:  LPWSTR string_buffer = (LPWSTR)_alloca(length * sizeof(WCHAR));
        -: 2096:  int result = error_wrapper(::WSAAddressToStringW(&address.base,
        -: 2097:        address_length, 0, string_buffer, &string_length), ec);
        -: 2098:  ::WideCharToMultiByte(CP_ACP, 0, string_buffer, -1,
        -: 2099:      dest, static_cast<int>(length), 0, 0);
        -: 2100:#else
        -: 2101:  int result = error_wrapper(::WSAAddressToStringA(
        -: 2102:        &address.base, address_length, 0, dest, &string_length), ec);
        -: 2103:#endif
        -: 2104:
        -: 2105:  // Windows may set error code on success.
        -: 2106:  if (result != socket_error_retval)
        -: 2107:    ec = boost::system::error_code();
        -: 2108:
        -: 2109:  // Windows may not set an error code on failure.
        -: 2110:  else if (result == socket_error_retval && !ec)
        -: 2111:    ec = boost::asio::error::invalid_argument;
        -: 2112:
        -: 2113:  return result == socket_error_retval ? 0 : dest;
        -: 2114:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2115:  const char* result = error_wrapper(::inet_ntop(
        -: 2116:        af, src, dest, static_cast<int>(length)), ec);
        -: 2117:  if (result == 0 && !ec)
        -: 2118:    ec = boost::asio::error::invalid_argument;
        -: 2119:  if (result != 0 && af == BOOST_ASIO_OS_DEF(AF_INET6) && scope_id != 0)
        -: 2120:  {
        -: 2121:    using namespace std; // For strcat and sprintf.
        -: 2122:    char if_name[(IF_NAMESIZE > 21 ? IF_NAMESIZE : 21) + 1] = "%";
        -: 2123:    const in6_addr_type* ipv6_address = static_cast<const in6_addr_type*>(src);
        -: 2124:    bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
        -: 2125:        && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
        -: 2126:    bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
        -: 2127:        && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
        -: 2128:    if ((!is_link_local && !is_multicast_link_local)
        -: 2129:        || if_indextoname(static_cast<unsigned>(scope_id), if_name + 1) == 0)
        -: 2130:      sprintf(if_name + 1, "%lu", scope_id);
        -: 2131:    strcat(dest, if_name);
        -: 2132:  }
        -: 2133:  return result;
        -: 2134:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2135:}
        -: 2136:
        2: 2137:int inet_pton(int af, const char* src, void* dest,
        -: 2138:    unsigned long* scope_id, boost::system::error_code& ec)
        -: 2139:{
        2: 2140:  clear_last_error();
        2: 2140-block  0
        -: 2141:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2142:  using namespace std; // For sscanf.
        -: 2143:  unsigned char* bytes = static_cast<unsigned char*>(dest);
        -: 2144:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2145:  {
        -: 2146:    unsigned int b0, b1, b2, b3;
        -: 2147:    if (sscanf_s(src, "%u.%u.%u.%u", &b0, &b1, &b2, &b3) != 4)
        -: 2148:    {
        -: 2149:      ec = boost::asio::error::invalid_argument;
        -: 2150:      return -1;
        -: 2151:    }
        -: 2152:    if (b0 > 255 || b1 > 255 || b2 > 255 || b3 > 255)
        -: 2153:    {
        -: 2154:      ec = boost::asio::error::invalid_argument;
        -: 2155:      return -1;
        -: 2156:    }
        -: 2157:    bytes[0] = static_cast<unsigned char>(b0);
        -: 2158:    bytes[1] = static_cast<unsigned char>(b1);
        -: 2159:    bytes[2] = static_cast<unsigned char>(b2);
        -: 2160:    bytes[3] = static_cast<unsigned char>(b3);
        -: 2161:    ec = boost::system::error_code();
        -: 2162:    return 1;
        -: 2163:  }
        -: 2164:  else if (af == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2165:  {
        -: 2166:    unsigned char* bytes = static_cast<unsigned char*>(dest);
        -: 2167:    std::memset(bytes, 0, 16);
        -: 2168:    unsigned char back_bytes[16] = { 0 };
        -: 2169:    int num_front_bytes = 0, num_back_bytes = 0;
        -: 2170:    const char* p = src;
        -: 2171:
        -: 2172:    enum { fword, fcolon, bword, scope, done } state = fword;
        -: 2173:    unsigned long current_word = 0;
        -: 2174:    while (state != done)
        -: 2175:    {
        -: 2176:      if (current_word > 0xFFFF)
        -: 2177:      {
        -: 2178:        ec = boost::asio::error::invalid_argument;
        -: 2179:        return -1;
        -: 2180:      }
        -: 2181:
        -: 2182:      switch (state)
        -: 2183:      {
        -: 2184:      case fword:
        -: 2185:        if (*p >= '0' && *p <= '9')
        -: 2186:          current_word = current_word * 16 + *p++ - '0';
        -: 2187:        else if (*p >= 'a' && *p <= 'f')
        -: 2188:          current_word = current_word * 16 + *p++ - 'a' + 10;
        -: 2189:        else if (*p >= 'A' && *p <= 'F')
        -: 2190:          current_word = current_word * 16 + *p++ - 'A' + 10;
        -: 2191:        else
        -: 2192:        {
        -: 2193:          if (num_front_bytes == 16)
        -: 2194:          {
        -: 2195:            ec = boost::asio::error::invalid_argument;
        -: 2196:            return -1;
        -: 2197:          }
        -: 2198:
        -: 2199:          bytes[num_front_bytes++] = (current_word >> 8) & 0xFF;
        -: 2200:          bytes[num_front_bytes++] = current_word & 0xFF;
        -: 2201:          current_word = 0;
        -: 2202:
        -: 2203:          if (*p == ':')
        -: 2204:            state = fcolon, ++p;
        -: 2205:          else if (*p == '%')
        -: 2206:            state = scope, ++p;
        -: 2207:          else if (*p == 0)
        -: 2208:            state = done;
        -: 2209:          else
        -: 2210:          {
        -: 2211:            ec = boost::asio::error::invalid_argument;
        -: 2212:            return -1;
        -: 2213:          }
        -: 2214:        }
        -: 2215:        break;
        -: 2216:
        -: 2217:      case fcolon:
        -: 2218:        if (*p == ':')
        -: 2219:          state = bword, ++p;
        -: 2220:        else
        -: 2221:          state = fword;
        -: 2222:        break;
        -: 2223:
        -: 2224:      case bword:
        -: 2225:        if (*p >= '0' && *p <= '9')
        -: 2226:          current_word = current_word * 16 + *p++ - '0';
        -: 2227:        else if (*p >= 'a' && *p <= 'f')
        -: 2228:          current_word = current_word * 16 + *p++ - 'a' + 10;
        -: 2229:        else if (*p >= 'A' && *p <= 'F')
        -: 2230:          current_word = current_word * 16 + *p++ - 'A' + 10;
        -: 2231:        else
        -: 2232:        {
        -: 2233:          if (num_front_bytes + num_back_bytes == 16)
        -: 2234:          {
        -: 2235:            ec = boost::asio::error::invalid_argument;
        -: 2236:            return -1;
        -: 2237:          }
        -: 2238:
        -: 2239:          back_bytes[num_back_bytes++] = (current_word >> 8) & 0xFF;
        -: 2240:          back_bytes[num_back_bytes++] = current_word & 0xFF;
        -: 2241:          current_word = 0;
        -: 2242:
        -: 2243:          if (*p == ':')
        -: 2244:            state = bword, ++p;
        -: 2245:          else if (*p == '%')
        -: 2246:            state = scope, ++p;
        -: 2247:          else if (*p == 0)
        -: 2248:            state = done;
        -: 2249:          else
        -: 2250:          {
        -: 2251:            ec = boost::asio::error::invalid_argument;
        -: 2252:            return -1;
        -: 2253:          }
        -: 2254:        }
        -: 2255:        break;
        -: 2256:
        -: 2257:      case scope:
        -: 2258:        if (*p >= '0' && *p <= '9')
        -: 2259:          current_word = current_word * 10 + *p++ - '0';
        -: 2260:        else if (*p == 0)
        -: 2261:          *scope_id = current_word, state = done;
        -: 2262:        else
        -: 2263:        {
        -: 2264:          ec = boost::asio::error::invalid_argument;
        -: 2265:          return -1;
        -: 2266:        }
        -: 2267:        break;
        -: 2268:
        -: 2269:      default:
        -: 2270:        break;
        -: 2271:      }
        -: 2272:    }
        -: 2273:
        -: 2274:    for (int i = 0; i < num_back_bytes; ++i)
        -: 2275:      bytes[16 - num_back_bytes + i] = back_bytes[i];
        -: 2276:
        -: 2277:    ec = boost::system::error_code();
        -: 2278:    return 1;
        -: 2279:  }
        -: 2280:  else
        -: 2281:  {
        -: 2282:    ec = boost::asio::error::address_family_not_supported;
        -: 2283:    return -1;
        -: 2284:  }
        -: 2285:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2286:  using namespace std; // For memcpy and strcmp.
        -: 2287:
        -: 2288:  if (af != BOOST_ASIO_OS_DEF(AF_INET) && af != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2289:  {
        -: 2290:    ec = boost::asio::error::address_family_not_supported;
        -: 2291:    return -1;
        -: 2292:  }
        -: 2293:
        -: 2294:  union
        -: 2295:  {
        -: 2296:    socket_addr_type base;
        -: 2297:    sockaddr_storage_type storage;
        -: 2298:    sockaddr_in4_type v4;
        -: 2299:    sockaddr_in6_type v6;
        -: 2300:  } address;
        -: 2301:  int address_length = sizeof(sockaddr_storage_type);
        -: 2302:#if defined(BOOST_NO_ANSI_APIS) || (defined(_MSC_VER) && (_MSC_VER >= 1800))
        -: 2303:  int num_wide_chars = static_cast<int>(strlen(src)) + 1;
        -: 2304:  LPWSTR wide_buffer = (LPWSTR)_alloca(num_wide_chars * sizeof(WCHAR));
        -: 2305:  ::MultiByteToWideChar(CP_ACP, 0, src, -1, wide_buffer, num_wide_chars);
        -: 2306:  int result = error_wrapper(::WSAStringToAddressW(
        -: 2307:        wide_buffer, af, 0, &address.base, &address_length), ec);
        -: 2308:#else
        -: 2309:  int result = error_wrapper(::WSAStringToAddressA(
        -: 2310:        const_cast<char*>(src), af, 0, &address.base, &address_length), ec);
        -: 2311:#endif
        -: 2312:
        -: 2313:  if (af == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2314:  {
        -: 2315:    if (result != socket_error_retval)
        -: 2316:    {
        -: 2317:      memcpy(dest, &address.v4.sin_addr, sizeof(in4_addr_type));
        -: 2318:      ec = boost::system::error_code();
        -: 2319:    }
        -: 2320:    else if (strcmp(src, "255.255.255.255") == 0)
        -: 2321:    {
        -: 2322:      static_cast<in4_addr_type*>(dest)->s_addr = INADDR_NONE;
        -: 2323:      ec = boost::system::error_code();
        -: 2324:    }
        -: 2325:  }
        -: 2326:  else // AF_INET6
        -: 2327:  {
        -: 2328:    if (result != socket_error_retval)
        -: 2329:    {
        -: 2330:      memcpy(dest, &address.v6.sin6_addr, sizeof(in6_addr_type));
        -: 2331:      if (scope_id)
        -: 2332:        *scope_id = address.v6.sin6_scope_id;
        -: 2333:      ec = boost::system::error_code();
        -: 2334:    }
        -: 2335:  }
        -: 2336:
        -: 2337:  // Windows may not set an error code on failure.
        -: 2338:  if (result == socket_error_retval && !ec)
        -: 2339:    ec = boost::asio::error::invalid_argument;
        -: 2340:
        -: 2341:  if (result != socket_error_retval)
        -: 2342:    ec = boost::system::error_code();
        -: 2343:
        -: 2344:  return result == socket_error_retval ? -1 : 1;
        -: 2345:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2346:  using namespace std; // For strchr, memcpy and atoi.
        -: 2347:
        -: 2348:  // On some platforms, inet_pton fails if an address string contains a scope
        -: 2349:  // id. Detect and remove the scope id before passing the string to inet_pton.
        2: 2350:  const bool is_v6 = (af == BOOST_ASIO_OS_DEF(AF_INET6));
        2: 2351:  const char* if_name = is_v6 ? strchr(src, '%') : 0;
        1: 2351-block  0
        1: 2351-block  1
        -: 2352:  char src_buf[max_addr_v6_str_len + 1];
        2: 2353:  const char* src_ptr = src;
        2: 2354:  if (if_name != 0)
        2: 2354-block  0
        -: 2355:  {
    #####: 2356:    if (if_name - src > max_addr_v6_str_len)
    %%%%%: 2356-block  0
        -: 2357:    {
    #####: 2358:      ec = boost::asio::error::invalid_argument;
    %%%%%: 2358-block  0
    #####: 2359:      return 0;
        -: 2360:    }
    #####: 2361:    memcpy(src_buf, src, if_name - src);
    #####: 2362:    src_buf[if_name - src] = 0;
    #####: 2363:    src_ptr = src_buf;
    %%%%%: 2363-block  0
        -: 2364:  }
        -: 2365:
        2: 2366:  int result = error_wrapper(::inet_pton(af, src_ptr, dest), ec);
        2: 2366-block  0
        2: 2367:  if (result <= 0 && !ec)
        1: 2367-block  0
        1: 2367-block  1
        1: 2367-block  2
        2: 2367-block  3
        1: 2368:    ec = boost::asio::error::invalid_argument;
        1: 2368-block  0
       2*: 2369:  if (result > 0 && is_v6 && scope_id)
        2: 2369-block  0
        1: 2369-block  1
    %%%%%: 2369-block  2
        -: 2370:  {
        -: 2371:    using namespace std; // For strchr and atoi.
    #####: 2372:    *scope_id = 0;
    #####: 2373:    if (if_name != 0)
    %%%%%: 2373-block  0
        -: 2374:    {
    #####: 2375:      in6_addr_type* ipv6_address = static_cast<in6_addr_type*>(dest);
    #####: 2376:      bool is_link_local = ((ipv6_address->s6_addr[0] == 0xfe)
    #####: 2377:          && ((ipv6_address->s6_addr[1] & 0xc0) == 0x80));
    %%%%%: 2377-block  0
    %%%%%: 2377-block  1
    %%%%%: 2377-block  2
    %%%%%: 2377-block  3
    #####: 2378:      bool is_multicast_link_local = ((ipv6_address->s6_addr[0] == 0xff)
    #####: 2379:          && ((ipv6_address->s6_addr[1] & 0x0f) == 0x02));
    %%%%%: 2379-block  0
    %%%%%: 2379-block  1
    %%%%%: 2379-block  2
    %%%%%: 2379-block  3
    #####: 2380:      if (is_link_local || is_multicast_link_local)
    %%%%%: 2380-block  0
    %%%%%: 2380-block  1
    #####: 2381:        *scope_id = if_nametoindex(if_name + 1);
    %%%%%: 2381-block  0
    #####: 2382:      if (*scope_id == 0)
    %%%%%: 2382-block  0
    #####: 2383:        *scope_id = atoi(if_name + 1);
    %%%%%: 2383-block  0
        -: 2384:    }
        -: 2385:  }
        2: 2386:  return result;
        2: 2386-block  0
        -: 2387:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2388:}
        -: 2389:
        -: 2390:int gethostname(char* name, int namelen, boost::system::error_code& ec)
        -: 2391:{
        -: 2392:  clear_last_error();
        -: 2393:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2394:  try
        -: 2395:  {
        -: 2396:    using namespace Windows::Foundation::Collections;
        -: 2397:    using namespace Windows::Networking;
        -: 2398:    using namespace Windows::Networking::Connectivity;
        -: 2399:    IVectorView<HostName^>^ hostnames = NetworkInformation::GetHostNames();
        -: 2400:    for (unsigned i = 0; i < hostnames->Size; ++i)
        -: 2401:    {
        -: 2402:      HostName^ hostname = hostnames->GetAt(i);
        -: 2403:      if (hostname->Type == HostNameType::DomainName)
        -: 2404:      {
        -: 2405:        std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
        -: 2406:        std::string raw_name = converter.to_bytes(hostname->RawName->Data());
        -: 2407:        if (namelen > 0 && raw_name.size() < static_cast<std::size_t>(namelen))
        -: 2408:        {
        -: 2409:          strcpy_s(name, namelen, raw_name.c_str());
        -: 2410:          return 0;
        -: 2411:        }
        -: 2412:      }
        -: 2413:    }
        -: 2414:    return -1;
        -: 2415:  }
        -: 2416:  catch (Platform::Exception^ e)
        -: 2417:  {
        -: 2418:    ec = boost::system::error_code(e->HResult,
        -: 2419:        boost::system::system_category());
        -: 2420:    return -1;
        -: 2421:  }
        -: 2422:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2423:  int result = error_wrapper(::gethostname(name, namelen), ec);
        -: 2424:# if defined(BOOST_ASIO_WINDOWS)
        -: 2425:  if (result == 0)
        -: 2426:    ec = boost::system::error_code();
        -: 2427:# endif // defined(BOOST_ASIO_WINDOWS)
        -: 2428:  return result;
        -: 2429:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2430:}
        -: 2431:
        -: 2432:#if !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 2433:
        -: 2434:#if !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 2435:
        -: 2436:// The following functions are only needed for emulation of getaddrinfo and
        -: 2437:// getnameinfo.
        -: 2438:
        -: 2439:inline boost::system::error_code translate_netdb_error(int error)
        -: 2440:{
        -: 2441:  switch (error)
        -: 2442:  {
        -: 2443:  case 0:
        -: 2444:    return boost::system::error_code();
        -: 2445:  case HOST_NOT_FOUND:
        -: 2446:    return boost::asio::error::host_not_found;
        -: 2447:  case TRY_AGAIN:
        -: 2448:    return boost::asio::error::host_not_found_try_again;
        -: 2449:  case NO_RECOVERY:
        -: 2450:    return boost::asio::error::no_recovery;
        -: 2451:  case NO_DATA:
        -: 2452:    return boost::asio::error::no_data;
        -: 2453:  default:
        -: 2454:    BOOST_ASIO_ASSERT(false);
        -: 2455:    return boost::asio::error::invalid_argument;
        -: 2456:  }
        -: 2457:}
        -: 2458:
        -: 2459:inline hostent* gethostbyaddr(const char* addr, int length, int af,
        -: 2460:    hostent* result, char* buffer, int buflength, boost::system::error_code& ec)
        -: 2461:{
        -: 2462:  clear_last_error();
        -: 2463:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2464:  (void)(buffer);
        -: 2465:  (void)(buflength);
        -: 2466:  hostent* retval = error_wrapper(::gethostbyaddr(addr, length, af), ec);
        -: 2467:  if (!retval)
        -: 2468:    return 0;
        -: 2469:  ec = boost::system::error_code();
        -: 2470:  *result = *retval;
        -: 2471:  return retval;
        -: 2472:#elif defined(__sun) || defined(__QNX__)
        -: 2473:  int error = 0;
        -: 2474:  hostent* retval = error_wrapper(::gethostbyaddr_r(addr, length, af, result,
        -: 2475:        buffer, buflength, &error), ec);
        -: 2476:  if (error)
        -: 2477:    ec = translate_netdb_error(error);
        -: 2478:  return retval;
        -: 2479:#elif defined(__MACH__) && defined(__APPLE__)
        -: 2480:  (void)(buffer);
        -: 2481:  (void)(buflength);
        -: 2482:  int error = 0;
        -: 2483:  hostent* retval = error_wrapper(::getipnodebyaddr(
        -: 2484:        addr, length, af, &error), ec);
        -: 2485:  if (error)
        -: 2486:    ec = translate_netdb_error(error);
        -: 2487:  if (!retval)
        -: 2488:    return 0;
        -: 2489:  *result = *retval;
        -: 2490:  return retval;
        -: 2491:#else
        -: 2492:  hostent* retval = 0;
        -: 2493:  int error = 0;
        -: 2494:  error_wrapper(::gethostbyaddr_r(addr, length, af, result, buffer,
        -: 2495:        buflength, &retval, &error), ec);
        -: 2496:  if (error)
        -: 2497:    ec = translate_netdb_error(error);
        -: 2498:  return retval;
        -: 2499:#endif
        -: 2500:}
        -: 2501:
        -: 2502:inline hostent* gethostbyname(const char* name, int af, struct hostent* result,
        -: 2503:    char* buffer, int buflength, int ai_flags, boost::system::error_code& ec)
        -: 2504:{
        -: 2505:  clear_last_error();
        -: 2506:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 2507:  (void)(buffer);
        -: 2508:  (void)(buflength);
        -: 2509:  (void)(ai_flags);
        -: 2510:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2511:  {
        -: 2512:    ec = boost::asio::error::address_family_not_supported;
        -: 2513:    return 0;
        -: 2514:  }
        -: 2515:  hostent* retval = error_wrapper(::gethostbyname(name), ec);
        -: 2516:  if (!retval)
        -: 2517:    return 0;
        -: 2518:  ec = boost::system::error_code();
        -: 2519:  *result = *retval;
        -: 2520:  return result;
        -: 2521:#elif defined(__sun) || defined(__QNX__)
        -: 2522:  (void)(ai_flags);
        -: 2523:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2524:  {
        -: 2525:    ec = boost::asio::error::address_family_not_supported;
        -: 2526:    return 0;
        -: 2527:  }
        -: 2528:  int error = 0;
        -: 2529:  hostent* retval = error_wrapper(::gethostbyname_r(name, result, buffer,
        -: 2530:        buflength, &error), ec);
        -: 2531:  if (error)
        -: 2532:    ec = translate_netdb_error(error);
        -: 2533:  return retval;
        -: 2534:#elif defined(__MACH__) && defined(__APPLE__)
        -: 2535:  (void)(buffer);
        -: 2536:  (void)(buflength);
        -: 2537:  int error = 0;
        -: 2538:  hostent* retval = error_wrapper(::getipnodebyname(
        -: 2539:        name, af, ai_flags, &error), ec);
        -: 2540:  if (error)
        -: 2541:    ec = translate_netdb_error(error);
        -: 2542:  if (!retval)
        -: 2543:    return 0;
        -: 2544:  *result = *retval;
        -: 2545:  return retval;
        -: 2546:#else
        -: 2547:  (void)(ai_flags);
        -: 2548:  if (af != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2549:  {
        -: 2550:    ec = boost::asio::error::address_family_not_supported;
        -: 2551:    return 0;
        -: 2552:  }
        -: 2553:  hostent* retval = 0;
        -: 2554:  int error = 0;
        -: 2555:  error_wrapper(::gethostbyname_r(name, result,
        -: 2556:        buffer, buflength, &retval, &error), ec);
        -: 2557:  if (error)
        -: 2558:    ec = translate_netdb_error(error);
        -: 2559:  return retval;
        -: 2560:#endif
        -: 2561:}
        -: 2562:
        -: 2563:inline void freehostent(hostent* h)
        -: 2564:{
        -: 2565:#if defined(__MACH__) && defined(__APPLE__)
        -: 2566:  if (h)
        -: 2567:    ::freehostent(h);
        -: 2568:#else
        -: 2569:  (void)(h);
        -: 2570:#endif
        -: 2571:}
        -: 2572:
        -: 2573:// Emulation of getaddrinfo based on implementation in:
        -: 2574:// Stevens, W. R., UNIX Network Programming Vol. 1, 2nd Ed., Prentice-Hall 1998.
        -: 2575:
        -: 2576:struct gai_search
        -: 2577:{
        -: 2578:  const char* host;
        -: 2579:  int family;
        -: 2580:};
        -: 2581:
        -: 2582:inline int gai_nsearch(const char* host,
        -: 2583:    const addrinfo_type* hints, gai_search (&search)[2])
        -: 2584:{
        -: 2585:  int search_count = 0;
        -: 2586:  if (host == 0 || host[0] == '\0')
        -: 2587:  {
        -: 2588:    if (hints->ai_flags & AI_PASSIVE)
        -: 2589:    {
        -: 2590:      // No host and AI_PASSIVE implies wildcard bind.
        -: 2591:      switch (hints->ai_family)
        -: 2592:      {
        -: 2593:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2594:        search[search_count].host = "0.0.0.0";
        -: 2595:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2596:        ++search_count;
        -: 2597:        break;
        -: 2598:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2599:        search[search_count].host = "0::0";
        -: 2600:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2601:        ++search_count;
        -: 2602:        break;
        -: 2603:      case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2604:        search[search_count].host = "0::0";
        -: 2605:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2606:        ++search_count;
        -: 2607:        search[search_count].host = "0.0.0.0";
        -: 2608:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2609:        ++search_count;
        -: 2610:        break;
        -: 2611:      default:
        -: 2612:        break;
        -: 2613:      }
        -: 2614:    }
        -: 2615:    else
        -: 2616:    {
        -: 2617:      // No host and not AI_PASSIVE means connect to local host.
        -: 2618:      switch (hints->ai_family)
        -: 2619:      {
        -: 2620:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2621:        search[search_count].host = "localhost";
        -: 2622:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2623:        ++search_count;
        -: 2624:        break;
        -: 2625:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2626:        search[search_count].host = "localhost";
        -: 2627:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2628:        ++search_count;
        -: 2629:        break;
        -: 2630:      case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2631:        search[search_count].host = "localhost";
        -: 2632:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2633:        ++search_count;
        -: 2634:        search[search_count].host = "localhost";
        -: 2635:        search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2636:        ++search_count;
        -: 2637:        break;
        -: 2638:      default:
        -: 2639:        break;
        -: 2640:      }
        -: 2641:    }
        -: 2642:  }
        -: 2643:  else
        -: 2644:  {
        -: 2645:    // Host is specified.
        -: 2646:    switch (hints->ai_family)
        -: 2647:    {
        -: 2648:    case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2649:      search[search_count].host = host;
        -: 2650:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2651:      ++search_count;
        -: 2652:      break;
        -: 2653:    case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2654:      search[search_count].host = host;
        -: 2655:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2656:      ++search_count;
        -: 2657:      break;
        -: 2658:    case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2659:      search[search_count].host = host;
        -: 2660:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2661:      ++search_count;
        -: 2662:      search[search_count].host = host;
        -: 2663:      search[search_count].family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2664:      ++search_count;
        -: 2665:      break;
        -: 2666:    default:
        -: 2667:      break;
        -: 2668:    }
        -: 2669:  }
        -: 2670:  return search_count;
        -: 2671:}
        -: 2672:
        -: 2673:template <typename T>
        -: 2674:inline T* gai_alloc(std::size_t size = sizeof(T))
        -: 2675:{
        -: 2676:  using namespace std;
        -: 2677:  T* p = static_cast<T*>(::operator new(size, std::nothrow));
        -: 2678:  if (p)
        -: 2679:    memset(p, 0, size);
        -: 2680:  return p;
        -: 2681:}
        -: 2682:
        -: 2683:inline void gai_free(void* p)
        -: 2684:{
        -: 2685:  ::operator delete(p);
        -: 2686:}
        -: 2687:
        -: 2688:inline void gai_strcpy(char* target, const char* source, std::size_t max_size)
        -: 2689:{
        -: 2690:  using namespace std;
        -: 2691:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2692:  strcpy_s(target, max_size, source);
        -: 2693:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2694:  *target = 0;
        -: 2695:  if (max_size > 0)
        -: 2696:    strncat(target, source, max_size - 1);
        -: 2697:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 2698:}
        -: 2699:
        -: 2700:enum { gai_clone_flag = 1 << 30 };
        -: 2701:
        -: 2702:inline int gai_aistruct(addrinfo_type*** next, const addrinfo_type* hints,
        -: 2703:    const void* addr, int family)
        -: 2704:{
        -: 2705:  using namespace std;
        -: 2706:
        -: 2707:  addrinfo_type* ai = gai_alloc<addrinfo_type>();
        -: 2708:  if (ai == 0)
        -: 2709:    return EAI_MEMORY;
        -: 2710:
        -: 2711:  ai->ai_next = 0;
        -: 2712:  **next = ai;
        -: 2713:  *next = &ai->ai_next;
        -: 2714:
        -: 2715:  ai->ai_canonname = 0;
        -: 2716:  ai->ai_socktype = hints->ai_socktype;
        -: 2717:  if (ai->ai_socktype == 0)
        -: 2718:    ai->ai_flags |= gai_clone_flag;
        -: 2719:  ai->ai_protocol = hints->ai_protocol;
        -: 2720:  ai->ai_family = family;
        -: 2721:
        -: 2722:  switch (ai->ai_family)
        -: 2723:  {
        -: 2724:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2725:    {
        -: 2726:      sockaddr_in4_type* sinptr = gai_alloc<sockaddr_in4_type>();
        -: 2727:      if (sinptr == 0)
        -: 2728:        return EAI_MEMORY;
        -: 2729:      sinptr->sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -: 2730:      memcpy(&sinptr->sin_addr, addr, sizeof(in4_addr_type));
        -: 2731:      ai->ai_addr = reinterpret_cast<sockaddr*>(sinptr);
        -: 2732:      ai->ai_addrlen = sizeof(sockaddr_in4_type);
        -: 2733:      break;
        -: 2734:    }
        -: 2735:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2736:    {
        -: 2737:      sockaddr_in6_type* sin6ptr = gai_alloc<sockaddr_in6_type>();
        -: 2738:      if (sin6ptr == 0)
        -: 2739:        return EAI_MEMORY;
        -: 2740:      sin6ptr->sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -: 2741:      memcpy(&sin6ptr->sin6_addr, addr, sizeof(in6_addr_type));
        -: 2742:      ai->ai_addr = reinterpret_cast<sockaddr*>(sin6ptr);
        -: 2743:      ai->ai_addrlen = sizeof(sockaddr_in6_type);
        -: 2744:      break;
        -: 2745:    }
        -: 2746:  default:
        -: 2747:    break;
        -: 2748:  }
        -: 2749:
        -: 2750:  return 0;
        -: 2751:}
        -: 2752:
        -: 2753:inline addrinfo_type* gai_clone(addrinfo_type* ai)
        -: 2754:{
        -: 2755:  using namespace std;
        -: 2756:
        -: 2757:  addrinfo_type* new_ai = gai_alloc<addrinfo_type>();
        -: 2758:  if (new_ai == 0)
        -: 2759:    return new_ai;
        -: 2760:
        -: 2761:  new_ai->ai_next = ai->ai_next;
        -: 2762:  ai->ai_next = new_ai;
        -: 2763:
        -: 2764:  new_ai->ai_flags = 0;
        -: 2765:  new_ai->ai_family = ai->ai_family;
        -: 2766:  new_ai->ai_socktype = ai->ai_socktype;
        -: 2767:  new_ai->ai_protocol = ai->ai_protocol;
        -: 2768:  new_ai->ai_canonname = 0;
        -: 2769:  new_ai->ai_addrlen = ai->ai_addrlen;
        -: 2770:  new_ai->ai_addr = gai_alloc<sockaddr>(ai->ai_addrlen);
        -: 2771:  memcpy(new_ai->ai_addr, ai->ai_addr, ai->ai_addrlen);
        -: 2772:
        -: 2773:  return new_ai;
        -: 2774:}
        -: 2775:
        -: 2776:inline int gai_port(addrinfo_type* aihead, int port, int socktype)
        -: 2777:{
        -: 2778:  int num_found = 0;
        -: 2779:
        -: 2780:  for (addrinfo_type* ai = aihead; ai; ai = ai->ai_next)
        -: 2781:  {
        -: 2782:    if (ai->ai_flags & gai_clone_flag)
        -: 2783:    {
        -: 2784:      if (ai->ai_socktype != 0)
        -: 2785:      {
        -: 2786:        ai = gai_clone(ai);
        -: 2787:        if (ai == 0)
        -: 2788:          return -1;
        -: 2789:        // ai now points to newly cloned entry.
        -: 2790:      }
        -: 2791:    }
        -: 2792:    else if (ai->ai_socktype != socktype)
        -: 2793:    {
        -: 2794:      // Ignore if mismatch on socket type.
        -: 2795:      continue;
        -: 2796:    }
        -: 2797:
        -: 2798:    ai->ai_socktype = socktype;
        -: 2799:
        -: 2800:    switch (ai->ai_family)
        -: 2801:    {
        -: 2802:    case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2803:      {
        -: 2804:        sockaddr_in4_type* sinptr =
        -: 2805:          reinterpret_cast<sockaddr_in4_type*>(ai->ai_addr);
        -: 2806:        sinptr->sin_port = port;
        -: 2807:        ++num_found;
        -: 2808:        break;
        -: 2809:      }
        -: 2810:    case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2811:      {
        -: 2812:        sockaddr_in6_type* sin6ptr =
        -: 2813:          reinterpret_cast<sockaddr_in6_type*>(ai->ai_addr);
        -: 2814:        sin6ptr->sin6_port = port;
        -: 2815:        ++num_found;
        -: 2816:        break;
        -: 2817:      }
        -: 2818:    default:
        -: 2819:      break;
        -: 2820:    }
        -: 2821:  }
        -: 2822:
        -: 2823:  return num_found;
        -: 2824:}
        -: 2825:
        -: 2826:inline int gai_serv(addrinfo_type* aihead,
        -: 2827:    const addrinfo_type* hints, const char* serv)
        -: 2828:{
        -: 2829:  using namespace std;
        -: 2830:
        -: 2831:  int num_found = 0;
        -: 2832:
        -: 2833:  if (
        -: 2834:#if defined(AI_NUMERICSERV)
        -: 2835:      (hints->ai_flags & AI_NUMERICSERV) ||
        -: 2836:#endif
        -: 2837:      isdigit(static_cast<unsigned char>(serv[0])))
        -: 2838:  {
        -: 2839:    int port = htons(atoi(serv));
        -: 2840:    if (hints->ai_socktype)
        -: 2841:    {
        -: 2842:      // Caller specifies socket type.
        -: 2843:      int rc = gai_port(aihead, port, hints->ai_socktype);
        -: 2844:      if (rc < 0)
        -: 2845:        return EAI_MEMORY;
        -: 2846:      num_found += rc;
        -: 2847:    }
        -: 2848:    else
        -: 2849:    {
        -: 2850:      // Caller does not specify socket type.
        -: 2851:      int rc = gai_port(aihead, port, SOCK_STREAM);
        -: 2852:      if (rc < 0)
        -: 2853:        return EAI_MEMORY;
        -: 2854:      num_found += rc;
        -: 2855:      rc = gai_port(aihead, port, SOCK_DGRAM);
        -: 2856:      if (rc < 0)
        -: 2857:        return EAI_MEMORY;
        -: 2858:      num_found += rc;
        -: 2859:    }
        -: 2860:  }
        -: 2861:  else
        -: 2862:  {
        -: 2863:    // Try service name with TCP first, then UDP.
        -: 2864:    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_STREAM)
        -: 2865:    {
        -: 2866:      servent* sptr = getservbyname(serv, "tcp");
        -: 2867:      if (sptr != 0)
        -: 2868:      {
        -: 2869:        int rc = gai_port(aihead, sptr->s_port, SOCK_STREAM);
        -: 2870:        if (rc < 0)
        -: 2871:          return EAI_MEMORY;
        -: 2872:        num_found += rc;
        -: 2873:      }
        -: 2874:    }
        -: 2875:    if (hints->ai_socktype == 0 || hints->ai_socktype == SOCK_DGRAM)
        -: 2876:    {
        -: 2877:      servent* sptr = getservbyname(serv, "udp");
        -: 2878:      if (sptr != 0)
        -: 2879:      {
        -: 2880:        int rc = gai_port(aihead, sptr->s_port, SOCK_DGRAM);
        -: 2881:        if (rc < 0)
        -: 2882:          return EAI_MEMORY;
        -: 2883:        num_found += rc;
        -: 2884:      }
        -: 2885:    }
        -: 2886:  }
        -: 2887:
        -: 2888:  if (num_found == 0)
        -: 2889:  {
        -: 2890:    if (hints->ai_socktype == 0)
        -: 2891:    {
        -: 2892:      // All calls to getservbyname() failed.
        -: 2893:      return EAI_NONAME;
        -: 2894:    }
        -: 2895:    else
        -: 2896:    {
        -: 2897:      // Service not supported for socket type.
        -: 2898:      return EAI_SERVICE;
        -: 2899:    }
        -: 2900:  }
        -: 2901:
        -: 2902:  return 0;
        -: 2903:}
        -: 2904:
        -: 2905:inline int gai_echeck(const char* host, const char* service,
        -: 2906:    int flags, int family, int socktype, int protocol)
        -: 2907:{
        -: 2908:  (void)(flags);
        -: 2909:  (void)(protocol);
        -: 2910:
        -: 2911:  // Host or service must be specified.
        -: 2912:  if (host == 0 || host[0] == '\0')
        -: 2913:    if (service == 0 || service[0] == '\0')
        -: 2914:      return EAI_NONAME;
        -: 2915:
        -: 2916:  // Check combination of family and socket type.
        -: 2917:  switch (family)
        -: 2918:  {
        -: 2919:  case BOOST_ASIO_OS_DEF(AF_UNSPEC):
        -: 2920:    break;
        -: 2921:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 2922:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 2923:    if (service != 0 && service[0] != '\0')
        -: 2924:      if (socktype != 0 && socktype != SOCK_STREAM && socktype != SOCK_DGRAM)
        -: 2925:        return EAI_SOCKTYPE;
        -: 2926:    break;
        -: 2927:  default:
        -: 2928:    return EAI_FAMILY;
        -: 2929:  }
        -: 2930:
        -: 2931:  return 0;
        -: 2932:}
        -: 2933:
        -: 2934:inline void freeaddrinfo_emulation(addrinfo_type* aihead)
        -: 2935:{
        -: 2936:  addrinfo_type* ai = aihead;
        -: 2937:  while (ai)
        -: 2938:  {
        -: 2939:    gai_free(ai->ai_addr);
        -: 2940:    gai_free(ai->ai_canonname);
        -: 2941:    addrinfo_type* ainext = ai->ai_next;
        -: 2942:    gai_free(ai);
        -: 2943:    ai = ainext;
        -: 2944:  }
        -: 2945:}
        -: 2946:
        -: 2947:inline int getaddrinfo_emulation(const char* host, const char* service,
        -: 2948:    const addrinfo_type* hintsp, addrinfo_type** result)
        -: 2949:{
        -: 2950:  // Set up linked list of addrinfo structures.
        -: 2951:  addrinfo_type* aihead = 0;
        -: 2952:  addrinfo_type** ainext = &aihead;
        -: 2953:  char* canon = 0;
        -: 2954:
        -: 2955:  // Supply default hints if not specified by caller.
        -: 2956:  addrinfo_type hints = addrinfo_type();
        -: 2957:  hints.ai_family = BOOST_ASIO_OS_DEF(AF_UNSPEC);
        -: 2958:  if (hintsp)
        -: 2959:    hints = *hintsp;
        -: 2960:
        -: 2961:  // If the resolution is not specifically for AF_INET6, remove the AI_V4MAPPED
        -: 2962:  // and AI_ALL flags.
        -: 2963:#if defined(AI_V4MAPPED)
        -: 2964:  if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2965:    hints.ai_flags &= ~AI_V4MAPPED;
        -: 2966:#endif
        -: 2967:#if defined(AI_ALL)
        -: 2968:  if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 2969:    hints.ai_flags &= ~AI_ALL;
        -: 2970:#endif
        -: 2971:
        -: 2972:  // Basic error checking.
        -: 2973:  int rc = gai_echeck(host, service, hints.ai_flags, hints.ai_family,
        -: 2974:      hints.ai_socktype, hints.ai_protocol);
        -: 2975:  if (rc != 0)
        -: 2976:  {
        -: 2977:    freeaddrinfo_emulation(aihead);
        -: 2978:    return rc;
        -: 2979:  }
        -: 2980:
        -: 2981:  gai_search search[2];
        -: 2982:  int search_count = gai_nsearch(host, &hints, search);
        -: 2983:  for (gai_search* sptr = search; sptr < search + search_count; ++sptr)
        -: 2984:  {
        -: 2985:    // Check for IPv4 dotted decimal string.
        -: 2986:    in4_addr_type inaddr;
        -: 2987:    boost::system::error_code ec;
        -: 2988:    if (socket_ops::inet_pton(BOOST_ASIO_OS_DEF(AF_INET),
        -: 2989:          sptr->host, &inaddr, 0, ec) == 1)
        -: 2990:    {
        -: 2991:      if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 2992:          && hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET))
        -: 2993:      {
        -: 2994:        freeaddrinfo_emulation(aihead);
        -: 2995:        gai_free(canon);
        -: 2996:        return EAI_FAMILY;
        -: 2997:      }
        -: 2998:      if (sptr->family == BOOST_ASIO_OS_DEF(AF_INET))
        -: 2999:      {
        -: 3000:        rc = gai_aistruct(&ainext, &hints, &inaddr, BOOST_ASIO_OS_DEF(AF_INET));
        -: 3001:        if (rc != 0)
        -: 3002:        {
        -: 3003:          freeaddrinfo_emulation(aihead);
        -: 3004:          gai_free(canon);
        -: 3005:          return rc;
        -: 3006:        }
        -: 3007:      }
        -: 3008:      continue;
        -: 3009:    }
        -: 3010:
        -: 3011:    // Check for IPv6 hex string.
        -: 3012:    in6_addr_type in6addr;
        -: 3013:    if (socket_ops::inet_pton(BOOST_ASIO_OS_DEF(AF_INET6),
        -: 3014:          sptr->host, &in6addr, 0, ec) == 1)
        -: 3015:    {
        -: 3016:      if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 3017:          && hints.ai_family != BOOST_ASIO_OS_DEF(AF_INET6))
        -: 3018:      {
        -: 3019:        freeaddrinfo_emulation(aihead);
        -: 3020:        gai_free(canon);
        -: 3021:        return EAI_FAMILY;
        -: 3022:      }
        -: 3023:      if (sptr->family == BOOST_ASIO_OS_DEF(AF_INET6))
        -: 3024:      {
        -: 3025:        rc = gai_aistruct(&ainext, &hints, &in6addr,
        -: 3026:            BOOST_ASIO_OS_DEF(AF_INET6));
        -: 3027:        if (rc != 0)
        -: 3028:        {
        -: 3029:          freeaddrinfo_emulation(aihead);
        -: 3030:          gai_free(canon);
        -: 3031:          return rc;
        -: 3032:        }
        -: 3033:      }
        -: 3034:      continue;
        -: 3035:    }
        -: 3036:
        -: 3037:    // Look up hostname.
        -: 3038:    hostent hent;
        -: 3039:    char hbuf[8192] = "";
        -: 3040:    hostent* hptr = socket_ops::gethostbyname(sptr->host,
        -: 3041:        sptr->family, &hent, hbuf, sizeof(hbuf), hints.ai_flags, ec);
        -: 3042:    if (hptr == 0)
        -: 3043:    {
        -: 3044:      if (search_count == 2)
        -: 3045:      {
        -: 3046:        // Failure is OK if there are multiple searches.
        -: 3047:        continue;
        -: 3048:      }
        -: 3049:      freeaddrinfo_emulation(aihead);
        -: 3050:      gai_free(canon);
        -: 3051:      if (ec == boost::asio::error::host_not_found)
        -: 3052:        return EAI_NONAME;
        -: 3053:      if (ec == boost::asio::error::host_not_found_try_again)
        -: 3054:        return EAI_AGAIN;
        -: 3055:      if (ec == boost::asio::error::no_recovery)
        -: 3056:        return EAI_FAIL;
        -: 3057:      if (ec == boost::asio::error::no_data)
        -: 3058:        return EAI_NONAME;
        -: 3059:      return EAI_NONAME;
        -: 3060:    }
        -: 3061:
        -: 3062:    // Check for address family mismatch if one was specified.
        -: 3063:    if (hints.ai_family != BOOST_ASIO_OS_DEF(AF_UNSPEC)
        -: 3064:        && hints.ai_family != hptr->h_addrtype)
        -: 3065:    {
        -: 3066:      freeaddrinfo_emulation(aihead);
        -: 3067:      gai_free(canon);
        -: 3068:      socket_ops::freehostent(hptr);
        -: 3069:      return EAI_FAMILY;
        -: 3070:    }
        -: 3071:
        -: 3072:    // Save canonical name first time.
        -: 3073:    if (host != 0 && host[0] != '\0' && hptr->h_name && hptr->h_name[0]
        -: 3074:        && (hints.ai_flags & AI_CANONNAME) && canon == 0)
        -: 3075:    {
        -: 3076:      std::size_t canon_len = strlen(hptr->h_name) + 1;
        -: 3077:      canon = gai_alloc<char>(canon_len);
        -: 3078:      if (canon == 0)
        -: 3079:      {
        -: 3080:        freeaddrinfo_emulation(aihead);
        -: 3081:        socket_ops::freehostent(hptr);
        -: 3082:        return EAI_MEMORY;
        -: 3083:      }
        -: 3084:      gai_strcpy(canon, hptr->h_name, canon_len);
        -: 3085:    }
        -: 3086:
        -: 3087:    // Create an addrinfo structure for each returned address.
        -: 3088:    for (char** ap = hptr->h_addr_list; *ap; ++ap)
        -: 3089:    {
        -: 3090:      rc = gai_aistruct(&ainext, &hints, *ap, hptr->h_addrtype);
        -: 3091:      if (rc != 0)
        -: 3092:      {
        -: 3093:        freeaddrinfo_emulation(aihead);
        -: 3094:        gai_free(canon);
        -: 3095:        socket_ops::freehostent(hptr);
        -: 3096:        return EAI_FAMILY;
        -: 3097:      }
        -: 3098:    }
        -: 3099:
        -: 3100:    socket_ops::freehostent(hptr);
        -: 3101:  }
        -: 3102:
        -: 3103:  // Check if we found anything.
        -: 3104:  if (aihead == 0)
        -: 3105:  {
        -: 3106:    gai_free(canon);
        -: 3107:    return EAI_NONAME;
        -: 3108:  }
        -: 3109:
        -: 3110:  // Return canonical name in first entry.
        -: 3111:  if (host != 0 && host[0] != '\0' && (hints.ai_flags & AI_CANONNAME))
        -: 3112:  {
        -: 3113:    if (canon)
        -: 3114:    {
        -: 3115:      aihead->ai_canonname = canon;
        -: 3116:      canon = 0;
        -: 3117:    }
        -: 3118:    else
        -: 3119:    {
        -: 3120:      std::size_t canonname_len = strlen(search[0].host) + 1;
        -: 3121:      aihead->ai_canonname = gai_alloc<char>(canonname_len);
        -: 3122:      if (aihead->ai_canonname == 0)
        -: 3123:      {
        -: 3124:        freeaddrinfo_emulation(aihead);
        -: 3125:        return EAI_MEMORY;
        -: 3126:      }
        -: 3127:      gai_strcpy(aihead->ai_canonname, search[0].host, canonname_len);
        -: 3128:    }
        -: 3129:  }
        -: 3130:  gai_free(canon);
        -: 3131:
        -: 3132:  // Process the service name.
        -: 3133:  if (service != 0 && service[0] != '\0')
        -: 3134:  {
        -: 3135:    rc = gai_serv(aihead, &hints, service);
        -: 3136:    if (rc != 0)
        -: 3137:    {
        -: 3138:      freeaddrinfo_emulation(aihead);
        -: 3139:      return rc;
        -: 3140:    }
        -: 3141:  }
        -: 3142:
        -: 3143:  // Return result to caller.
        -: 3144:  *result = aihead;
        -: 3145:  return 0;
        -: 3146:}
        -: 3147:
        -: 3148:inline boost::system::error_code getnameinfo_emulation(
        -: 3149:    const socket_addr_type* sa, std::size_t salen, char* host,
        -: 3150:    std::size_t hostlen, char* serv, std::size_t servlen, int flags,
        -: 3151:    boost::system::error_code& ec)
        -: 3152:{
        -: 3153:  using namespace std;
        -: 3154:
        -: 3155:  const char* addr;
        -: 3156:  size_t addr_len;
        -: 3157:  unsigned short port;
        -: 3158:  switch (sa->sa_family)
        -: 3159:  {
        -: 3160:  case BOOST_ASIO_OS_DEF(AF_INET):
        -: 3161:    if (salen != sizeof(sockaddr_in4_type))
        -: 3162:    {
        -: 3163:      return ec = boost::asio::error::invalid_argument;
        -: 3164:    }
        -: 3165:    addr = reinterpret_cast<const char*>(
        -: 3166:        &reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_addr);
        -: 3167:    addr_len = sizeof(in4_addr_type);
        -: 3168:    port = reinterpret_cast<const sockaddr_in4_type*>(sa)->sin_port;
        -: 3169:    break;
        -: 3170:  case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 3171:    if (salen != sizeof(sockaddr_in6_type))
        -: 3172:    {
        -: 3173:      return ec = boost::asio::error::invalid_argument;
        -: 3174:    }
        -: 3175:    addr = reinterpret_cast<const char*>(
        -: 3176:        &reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_addr);
        -: 3177:    addr_len = sizeof(in6_addr_type);
        -: 3178:    port = reinterpret_cast<const sockaddr_in6_type*>(sa)->sin6_port;
        -: 3179:    break;
        -: 3180:  default:
        -: 3181:    return ec = boost::asio::error::address_family_not_supported;
        -: 3182:  }
        -: 3183:
        -: 3184:  if (host && hostlen > 0)
        -: 3185:  {
        -: 3186:    if (flags & NI_NUMERICHOST)
        -: 3187:    {
        -: 3188:      if (socket_ops::inet_ntop(sa->sa_family, addr, host, hostlen, 0, ec) == 0)
        -: 3189:      {
        -: 3190:        return ec;
        -: 3191:      }
        -: 3192:    }
        -: 3193:    else
        -: 3194:    {
        -: 3195:      hostent hent;
        -: 3196:      char hbuf[8192] = "";
        -: 3197:      hostent* hptr = socket_ops::gethostbyaddr(addr,
        -: 3198:          static_cast<int>(addr_len), sa->sa_family,
        -: 3199:          &hent, hbuf, sizeof(hbuf), ec);
        -: 3200:      if (hptr && hptr->h_name && hptr->h_name[0] != '\0')
        -: 3201:      {
        -: 3202:        if (flags & NI_NOFQDN)
        -: 3203:        {
        -: 3204:          char* dot = strchr(hptr->h_name, '.');
        -: 3205:          if (dot)
        -: 3206:          {
        -: 3207:            *dot = 0;
        -: 3208:          }
        -: 3209:        }
        -: 3210:        gai_strcpy(host, hptr->h_name, hostlen);
        -: 3211:        socket_ops::freehostent(hptr);
        -: 3212:      }
        -: 3213:      else
        -: 3214:      {
        -: 3215:        socket_ops::freehostent(hptr);
        -: 3216:        if (flags & NI_NAMEREQD)
        -: 3217:        {
        -: 3218:          return ec = boost::asio::error::host_not_found;
        -: 3219:        }
        -: 3220:        if (socket_ops::inet_ntop(sa->sa_family,
        -: 3221:              addr, host, hostlen, 0, ec) == 0)
        -: 3222:        {
        -: 3223:          return ec;
        -: 3224:        }
        -: 3225:      }
        -: 3226:    }
        -: 3227:  }
        -: 3228:
        -: 3229:  if (serv && servlen > 0)
        -: 3230:  {
        -: 3231:    if (flags & NI_NUMERICSERV)
        -: 3232:    {
        -: 3233:      if (servlen < 6)
        -: 3234:      {
        -: 3235:        return ec = boost::asio::error::no_buffer_space;
        -: 3236:      }
        -: 3237:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3238:      sprintf_s(serv, servlen, "%u", ntohs(port));
        -: 3239:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3240:      sprintf(serv, "%u", ntohs(port));
        -: 3241:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3242:    }
        -: 3243:    else
        -: 3244:    {
        -: 3245:#if defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3246:      static ::pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
        -: 3247:      ::pthread_mutex_lock(&mutex);
        -: 3248:#endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3249:      servent* sptr = ::getservbyport(port, (flags & NI_DGRAM) ? "udp" : 0);
        -: 3250:      if (sptr && sptr->s_name && sptr->s_name[0] != '\0')
        -: 3251:      {
        -: 3252:        gai_strcpy(serv, sptr->s_name, servlen);
        -: 3253:      }
        -: 3254:      else
        -: 3255:      {
        -: 3256:        if (servlen < 6)
        -: 3257:        {
        -: 3258:          return ec = boost::asio::error::no_buffer_space;
        -: 3259:        }
        -: 3260:#if defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3261:        sprintf_s(serv, servlen, "%u", ntohs(port));
        -: 3262:#else // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3263:        sprintf(serv, "%u", ntohs(port));
        -: 3264:#endif // defined(BOOST_ASIO_HAS_SECURE_RTL)
        -: 3265:      }
        -: 3266:#if defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3267:      ::pthread_mutex_unlock(&mutex);
        -: 3268:#endif // defined(BOOST_ASIO_HAS_PTHREADS)
        -: 3269:    }
        -: 3270:  }
        -: 3271:
        -: 3272:  ec = boost::system::error_code();
        -: 3273:  return ec;
        -: 3274:}
        -: 3275:
        -: 3276:#endif // !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3277:
        -: 3278:inline boost::system::error_code translate_addrinfo_error(int error)
        -: 3279:{
        -: 3280:  switch (error)
        -: 3281:  {
        -: 3282:  case 0:
        -: 3283:    return boost::system::error_code();
        -: 3284:  case EAI_AGAIN:
        -: 3285:    return boost::asio::error::host_not_found_try_again;
        -: 3286:  case EAI_BADFLAGS:
        -: 3287:    return boost::asio::error::invalid_argument;
        -: 3288:  case EAI_FAIL:
        -: 3289:    return boost::asio::error::no_recovery;
        -: 3290:  case EAI_FAMILY:
        -: 3291:    return boost::asio::error::address_family_not_supported;
        -: 3292:  case EAI_MEMORY:
        -: 3293:    return boost::asio::error::no_memory;
        -: 3294:  case EAI_NONAME:
        -: 3295:#if defined(EAI_ADDRFAMILY)
        -: 3296:  case EAI_ADDRFAMILY:
        -: 3297:#endif
        -: 3298:#if defined(EAI_NODATA) && (EAI_NODATA != EAI_NONAME)
        -: 3299:  case EAI_NODATA:
        -: 3300:#endif
        -: 3301:    return boost::asio::error::host_not_found;
        -: 3302:  case EAI_SERVICE:
        -: 3303:    return boost::asio::error::service_not_found;
        -: 3304:  case EAI_SOCKTYPE:
        -: 3305:    return boost::asio::error::socket_type_not_supported;
        -: 3306:  default: // Possibly the non-portable EAI_SYSTEM.
        -: 3307:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3308:    return boost::system::error_code(
        -: 3309:        WSAGetLastError(), boost::asio::error::get_system_category());
        -: 3310:#else
        -: 3311:    return boost::system::error_code(
        -: 3312:        errno, boost::asio::error::get_system_category());
        -: 3313:#endif
        -: 3314:  }
        -: 3315:}
        -: 3316:
        -: 3317:boost::system::error_code getaddrinfo(const char* host,
        -: 3318:    const char* service, const addrinfo_type& hints,
        -: 3319:    addrinfo_type** result, boost::system::error_code& ec)
        -: 3320:{
        -: 3321:  host = (host && *host) ? host : 0;
        -: 3322:  service = (service && *service) ? service : 0;
        -: 3323:  clear_last_error();
        -: 3324:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3325:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3326:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3327:  int error = ::getaddrinfo(host, service, &hints, result);
        -: 3328:  return ec = translate_addrinfo_error(error);
        -: 3329:# else
        -: 3330:  // Building for Windows 2000 or earlier.
        -: 3331:  typedef int (WSAAPI *gai_t)(const char*,
        -: 3332:      const char*, const addrinfo_type*, addrinfo_type**);
        -: 3333:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3334:  {
        -: 3335:    if (gai_t gai = (gai_t)::GetProcAddress(winsock_module, "getaddrinfo"))
        -: 3336:    {
        -: 3337:      int error = gai(host, service, &hints, result);
        -: 3338:      return ec = translate_addrinfo_error(error);
        -: 3339:    }
        -: 3340:  }
        -: 3341:  int error = getaddrinfo_emulation(host, service, &hints, result);
        -: 3342:  return ec = translate_addrinfo_error(error);
        -: 3343:# endif
        -: 3344:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3345:  int error = getaddrinfo_emulation(host, service, &hints, result);
        -: 3346:  return ec = translate_addrinfo_error(error);
        -: 3347:#else
        -: 3348:  int error = ::getaddrinfo(host, service, &hints, result);
        -: 3349:#if defined(__MACH__) && defined(__APPLE__)
        -: 3350:  using namespace std; // For isdigit and atoi.
        -: 3351:  if (error == 0 && service && isdigit(static_cast<unsigned char>(service[0])))
        -: 3352:  {
        -: 3353:    u_short_type port = host_to_network_short(atoi(service));
        -: 3354:    for (addrinfo_type* ai = *result; ai; ai = ai->ai_next)
        -: 3355:    {
        -: 3356:      switch (ai->ai_family)
        -: 3357:      {
        -: 3358:      case BOOST_ASIO_OS_DEF(AF_INET):
        -: 3359:        {
        -: 3360:          sockaddr_in4_type* sinptr =
        -: 3361:            reinterpret_cast<sockaddr_in4_type*>(ai->ai_addr);
        -: 3362:          if (sinptr->sin_port == 0)
        -: 3363:            sinptr->sin_port = port;
        -: 3364:          break;
        -: 3365:        }
        -: 3366:      case BOOST_ASIO_OS_DEF(AF_INET6):
        -: 3367:        {
        -: 3368:          sockaddr_in6_type* sin6ptr =
        -: 3369:            reinterpret_cast<sockaddr_in6_type*>(ai->ai_addr);
        -: 3370:          if (sin6ptr->sin6_port == 0)
        -: 3371:            sin6ptr->sin6_port = port;
        -: 3372:          break;
        -: 3373:        }
        -: 3374:      default:
        -: 3375:        break;
        -: 3376:      }
        -: 3377:    }
        -: 3378:  }
        -: 3379:#endif
        -: 3380:  return ec = translate_addrinfo_error(error);
        -: 3381:#endif
        -: 3382:}
        -: 3383:
        -: 3384:boost::system::error_code background_getaddrinfo(
        -: 3385:    const weak_cancel_token_type& cancel_token, const char* host,
        -: 3386:    const char* service, const addrinfo_type& hints,
        -: 3387:    addrinfo_type** result, boost::system::error_code& ec)
        -: 3388:{
        -: 3389:  if (cancel_token.expired())
        -: 3390:    ec = boost::asio::error::operation_aborted;
        -: 3391:  else
        -: 3392:    socket_ops::getaddrinfo(host, service, hints, result, ec);
        -: 3393:  return ec;
        -: 3394:}
        -: 3395:
        -: 3396:void freeaddrinfo(addrinfo_type* ai)
        -: 3397:{
        -: 3398:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3399:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3400:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3401:  ::freeaddrinfo(ai);
        -: 3402:# else
        -: 3403:  // Building for Windows 2000 or earlier.
        -: 3404:  typedef int (WSAAPI *fai_t)(addrinfo_type*);
        -: 3405:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3406:  {
        -: 3407:    if (fai_t fai = (fai_t)::GetProcAddress(winsock_module, "freeaddrinfo"))
        -: 3408:    {
        -: 3409:      fai(ai);
        -: 3410:      return;
        -: 3411:    }
        -: 3412:  }
        -: 3413:  freeaddrinfo_emulation(ai);
        -: 3414:# endif
        -: 3415:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3416:  freeaddrinfo_emulation(ai);
        -: 3417:#else
        -: 3418:  ::freeaddrinfo(ai);
        -: 3419:#endif
        -: 3420:}
        -: 3421:
        -: 3422:boost::system::error_code getnameinfo(const socket_addr_type* addr,
        -: 3423:    std::size_t addrlen, char* host, std::size_t hostlen,
        -: 3424:    char* serv, std::size_t servlen, int flags, boost::system::error_code& ec)
        -: 3425:{
        -: 3426:#if defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -: 3427:# if defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3428:  // Building for Windows XP, Windows Server 2003, or later.
        -: 3429:  clear_last_error();
        -: 3430:  int error = ::getnameinfo(addr, static_cast<socklen_t>(addrlen),
        -: 3431:      host, static_cast<DWORD>(hostlen),
        -: 3432:      serv, static_cast<DWORD>(servlen), flags);
        -: 3433:  return ec = translate_addrinfo_error(error);
        -: 3434:# else
        -: 3435:  // Building for Windows 2000 or earlier.
        -: 3436:  typedef int (WSAAPI *gni_t)(const socket_addr_type*,
        -: 3437:      int, char*, DWORD, char*, DWORD, int);
        -: 3438:  if (HMODULE winsock_module = ::GetModuleHandleA("ws2_32"))
        -: 3439:  {
        -: 3440:    if (gni_t gni = (gni_t)::GetProcAddress(winsock_module, "getnameinfo"))
        -: 3441:    {
        -: 3442:      clear_last_error();
        -: 3443:      int error = gni(addr, static_cast<int>(addrlen),
        -: 3444:          host, static_cast<DWORD>(hostlen),
        -: 3445:          serv, static_cast<DWORD>(servlen), flags);
        -: 3446:      return ec = translate_addrinfo_error(error);
        -: 3447:    }
        -: 3448:  }
        -: 3449:  clear_last_error();
        -: 3450:  return getnameinfo_emulation(addr, addrlen,
        -: 3451:      host, hostlen, serv, servlen, flags, ec);
        -: 3452:# endif
        -: 3453:#elif !defined(BOOST_ASIO_HAS_GETADDRINFO)
        -: 3454:  using namespace std; // For memcpy.
        -: 3455:  sockaddr_storage_type tmp_addr;
        -: 3456:  memcpy(&tmp_addr, addr, addrlen);
        -: 3457:  addr = reinterpret_cast<socket_addr_type*>(&tmp_addr);
        -: 3458:  clear_last_error();
        -: 3459:  return getnameinfo_emulation(addr, addrlen,
        -: 3460:      host, hostlen, serv, servlen, flags, ec);
        -: 3461:#else
        -: 3462:  clear_last_error();
        -: 3463:  int error = ::getnameinfo(addr, addrlen, host, hostlen, serv, servlen, flags);
        -: 3464:  return ec = translate_addrinfo_error(error);
        -: 3465:#endif
        -: 3466:}
        -: 3467:
        -: 3468:boost::system::error_code sync_getnameinfo(
        -: 3469:    const socket_addr_type* addr, std::size_t addrlen,
        -: 3470:    char* host, std::size_t hostlen, char* serv,
        -: 3471:    std::size_t servlen, int sock_type, boost::system::error_code& ec)
        -: 3472:{
        -: 3473:  // First try resolving with the service name. If that fails try resolving
        -: 3474:  // but allow the service to be returned as a number.
        -: 3475:  int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
        -: 3476:  socket_ops::getnameinfo(addr, addrlen, host,
        -: 3477:      hostlen, serv, servlen, flags, ec);
        -: 3478:  if (ec)
        -: 3479:  {
        -: 3480:    socket_ops::getnameinfo(addr, addrlen, host, hostlen,
        -: 3481:        serv, servlen, flags | NI_NUMERICSERV, ec);
        -: 3482:  }
        -: 3483:
        -: 3484:  return ec;
        -: 3485:}
        -: 3486:
        -: 3487:boost::system::error_code background_getnameinfo(
        -: 3488:    const weak_cancel_token_type& cancel_token,
        -: 3489:    const socket_addr_type* addr, std::size_t addrlen,
        -: 3490:    char* host, std::size_t hostlen, char* serv,
        -: 3491:    std::size_t servlen, int sock_type, boost::system::error_code& ec)
        -: 3492:{
        -: 3493:  if (cancel_token.expired())
        -: 3494:  {
        -: 3495:    ec = boost::asio::error::operation_aborted;
        -: 3496:  }
        -: 3497:  else
        -: 3498:  {
        -: 3499:    // First try resolving with the service name. If that fails try resolving
        -: 3500:    // but allow the service to be returned as a number.
        -: 3501:    int flags = (sock_type == SOCK_DGRAM) ? NI_DGRAM : 0;
        -: 3502:    socket_ops::getnameinfo(addr, addrlen, host,
        -: 3503:        hostlen, serv, servlen, flags, ec);
        -: 3504:    if (ec)
        -: 3505:    {
        -: 3506:      socket_ops::getnameinfo(addr, addrlen, host, hostlen,
        -: 3507:          serv, servlen, flags | NI_NUMERICSERV, ec);
        -: 3508:    }
        -: 3509:  }
        -: 3510:
        -: 3511:  return ec;
        -: 3512:}
        -: 3513:
        -: 3514:#endif // !defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3515:
        1: 3516:u_long_type network_to_host_long(u_long_type value)
        -: 3517:{
        -: 3518:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3519:  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
        -: 3520:  u_long_type result = (static_cast<u_long_type>(value_p[0]) << 24)
        -: 3521:    | (static_cast<u_long_type>(value_p[1]) << 16)
        -: 3522:    | (static_cast<u_long_type>(value_p[2]) << 8)
        -: 3523:    | static_cast<u_long_type>(value_p[3]);
        -: 3524:  return result;
        -: 3525:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        1: 3526:  return ntohl(value);
        1: 3526-block  0
        -: 3527:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3528:}
        -: 3529:
        1: 3530:u_long_type host_to_network_long(u_long_type value)
        -: 3531:{
        -: 3532:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3533:  u_long_type result;
        -: 3534:  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
        -: 3535:  result_p[0] = static_cast<unsigned char>((value >> 24) & 0xFF);
        -: 3536:  result_p[1] = static_cast<unsigned char>((value >> 16) & 0xFF);
        -: 3537:  result_p[2] = static_cast<unsigned char>((value >> 8) & 0xFF);
        -: 3538:  result_p[3] = static_cast<unsigned char>(value & 0xFF);
        -: 3539:  return result;
        -: 3540:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        1: 3541:  return htonl(value);
        1: 3541-block  0
        -: 3542:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3543:}
        -: 3544:
        -: 3545:u_short_type network_to_host_short(u_short_type value)
        -: 3546:{
        -: 3547:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3548:  unsigned char* value_p = reinterpret_cast<unsigned char*>(&value);
        -: 3549:  u_short_type result = (static_cast<u_short_type>(value_p[0]) << 8)
        -: 3550:    | static_cast<u_short_type>(value_p[1]);
        -: 3551:  return result;
        -: 3552:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3553:  return ntohs(value);
        -: 3554:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3555:}
        -: 3556:
        1: 3557:u_short_type host_to_network_short(u_short_type value)
        -: 3558:{
        -: 3559:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3560:  u_short_type result;
        -: 3561:  unsigned char* result_p = reinterpret_cast<unsigned char*>(&result);
        -: 3562:  result_p[0] = static_cast<unsigned char>((value >> 8) & 0xFF);
        -: 3563:  result_p[1] = static_cast<unsigned char>(value & 0xFF);
        -: 3564:  return result;
        -: 3565:#else // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        1: 3566:  return htons(value);
        1: 3566-block  0
        -: 3567:#endif // defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -: 3568:}
        -: 3569:
        -: 3570:} // namespace socket_ops
        -: 3571:} // namespace detail
        -: 3572:} // namespace asio
        -: 3573:} // namespace boost
        -: 3574:
        -: 3575:#include <boost/asio/detail/pop_options.hpp>
        -: 3576:
        -: 3577:#endif // BOOST_ASIO_DETAIL_SOCKET_OPS_IPP
