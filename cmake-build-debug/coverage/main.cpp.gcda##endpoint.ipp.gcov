        -:    0:Source:/usr/include/boost/asio/ip/detail/impl/endpoint.ipp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// ip/detail/impl/endpoint.ipp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
        -:   12:#define BOOST_ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:#include <cstring>
        -:   20:#if !defined(BOOST_ASIO_NO_IOSTREAM)
        -:   21:# include <sstream>
        -:   22:#endif // !defined(BOOST_ASIO_NO_IOSTREAM)
        -:   23:#include <boost/asio/detail/socket_ops.hpp>
        -:   24:#include <boost/asio/detail/throw_error.hpp>
        -:   25:#include <boost/asio/error.hpp>
        -:   26:#include <boost/asio/ip/detail/endpoint.hpp>
        -:   27:
        -:   28:#include <boost/asio/detail/push_options.hpp>
        -:   29:
        -:   30:namespace boost {
        -:   31:namespace asio {
        -:   32:namespace ip {
        -:   33:namespace detail {
        -:   34:
        2:   35:endpoint::endpoint() BOOST_ASIO_NOEXCEPT
        2:   36:  : data_()
        -:   37:{
        2:   38:  data_.v4.sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        2:   39:  data_.v4.sin_port = 0;
        2:   40:  data_.v4.sin_addr.s_addr = BOOST_ASIO_OS_DEF(INADDR_ANY);
        2:   41:}
        -:   42:
        -:   43:endpoint::endpoint(int family, unsigned short port_num) BOOST_ASIO_NOEXCEPT
        -:   44:  : data_()
        -:   45:{
        -:   46:  using namespace std; // For memcpy.
        -:   47:  if (family == BOOST_ASIO_OS_DEF(AF_INET))
        -:   48:  {
        -:   49:    data_.v4.sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -:   50:    data_.v4.sin_port =
        -:   51:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:   52:    data_.v4.sin_addr.s_addr = BOOST_ASIO_OS_DEF(INADDR_ANY);
        -:   53:  }
        -:   54:  else
        -:   55:  {
        -:   56:    data_.v6.sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -:   57:    data_.v6.sin6_port =
        -:   58:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:   59:    data_.v6.sin6_flowinfo = 0;
        -:   60:    data_.v6.sin6_addr.s6_addr[0] = 0; data_.v6.sin6_addr.s6_addr[1] = 0;
        -:   61:    data_.v6.sin6_addr.s6_addr[2] = 0; data_.v6.sin6_addr.s6_addr[3] = 0;
        -:   62:    data_.v6.sin6_addr.s6_addr[4] = 0; data_.v6.sin6_addr.s6_addr[5] = 0;
        -:   63:    data_.v6.sin6_addr.s6_addr[6] = 0; data_.v6.sin6_addr.s6_addr[7] = 0;
        -:   64:    data_.v6.sin6_addr.s6_addr[8] = 0; data_.v6.sin6_addr.s6_addr[9] = 0;
        -:   65:    data_.v6.sin6_addr.s6_addr[10] = 0; data_.v6.sin6_addr.s6_addr[11] = 0;
        -:   66:    data_.v6.sin6_addr.s6_addr[12] = 0; data_.v6.sin6_addr.s6_addr[13] = 0;
        -:   67:    data_.v6.sin6_addr.s6_addr[14] = 0; data_.v6.sin6_addr.s6_addr[15] = 0;
        -:   68:    data_.v6.sin6_scope_id = 0;
        -:   69:  }
        -:   70:}
        -:   71:
        -:   72:endpoint::endpoint(const boost::asio::ip::address& addr,
        -:   73:    unsigned short port_num) BOOST_ASIO_NOEXCEPT
        -:   74:  : data_()
        -:   75:{
        -:   76:  using namespace std; // For memcpy.
        -:   77:  if (addr.is_v4())
        -:   78:  {
        -:   79:    data_.v4.sin_family = BOOST_ASIO_OS_DEF(AF_INET);
        -:   80:    data_.v4.sin_port =
        -:   81:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:   82:    data_.v4.sin_addr.s_addr =
        -:   83:      boost::asio::detail::socket_ops::host_to_network_long(
        -:   84:        addr.to_v4().to_uint());
        -:   85:  }
        -:   86:  else
        -:   87:  {
        -:   88:    data_.v6.sin6_family = BOOST_ASIO_OS_DEF(AF_INET6);
        -:   89:    data_.v6.sin6_port =
        -:   90:      boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:   91:    data_.v6.sin6_flowinfo = 0;
        -:   92:    boost::asio::ip::address_v6 v6_addr = addr.to_v6();
        -:   93:    boost::asio::ip::address_v6::bytes_type bytes = v6_addr.to_bytes();
        -:   94:    memcpy(data_.v6.sin6_addr.s6_addr, bytes.data(), 16);
        -:   95:    data_.v6.sin6_scope_id =
        -:   96:      static_cast<boost::asio::detail::u_long_type>(
        -:   97:        v6_addr.scope_id());
        -:   98:  }
        -:   99:}
        -:  100:
        -:  101:void endpoint::resize(std::size_t new_size)
        -:  102:{
        -:  103:  if (new_size > sizeof(boost::asio::detail::sockaddr_storage_type))
        -:  104:  {
        -:  105:    boost::system::error_code ec(boost::asio::error::invalid_argument);
        -:  106:    boost::asio::detail::throw_error(ec);
        -:  107:  }
        -:  108:}
        -:  109:
        -:  110:unsigned short endpoint::port() const BOOST_ASIO_NOEXCEPT
        -:  111:{
        -:  112:  if (is_v4())
        -:  113:  {
        -:  114:    return boost::asio::detail::socket_ops::network_to_host_short(
        -:  115:        data_.v4.sin_port);
        -:  116:  }
        -:  117:  else
        -:  118:  {
        -:  119:    return boost::asio::detail::socket_ops::network_to_host_short(
        -:  120:        data_.v6.sin6_port);
        -:  121:  }
        -:  122:}
        -:  123:
        -:  124:void endpoint::port(unsigned short port_num) BOOST_ASIO_NOEXCEPT
        -:  125:{
        -:  126:  if (is_v4())
        -:  127:  {
        -:  128:    data_.v4.sin_port
        -:  129:      = boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:  130:  }
        -:  131:  else
        -:  132:  {
        -:  133:    data_.v6.sin6_port
        -:  134:      = boost::asio::detail::socket_ops::host_to_network_short(port_num);
        -:  135:  }
        -:  136:}
        -:  137:
        -:  138:boost::asio::ip::address endpoint::address() const BOOST_ASIO_NOEXCEPT
        -:  139:{
        -:  140:  using namespace std; // For memcpy.
        -:  141:  if (is_v4())
        -:  142:  {
        -:  143:    return boost::asio::ip::address_v4(
        -:  144:        boost::asio::detail::socket_ops::network_to_host_long(
        -:  145:          data_.v4.sin_addr.s_addr));
        -:  146:  }
        -:  147:  else
        -:  148:  {
        -:  149:    boost::asio::ip::address_v6::bytes_type bytes;
        -:  150:#if defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:  151:    memcpy(bytes.data(), data_.v6.sin6_addr.s6_addr, 16);
        -:  152:#else // defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:  153:    memcpy(bytes.elems, data_.v6.sin6_addr.s6_addr, 16);
        -:  154:#endif // defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:  155:    return boost::asio::ip::address_v6(bytes, data_.v6.sin6_scope_id);
        -:  156:  }
        -:  157:}
        -:  158:
        -:  159:void endpoint::address(const boost::asio::ip::address& addr) BOOST_ASIO_NOEXCEPT
        -:  160:{
        -:  161:  endpoint tmp_endpoint(addr, port());
        -:  162:  data_ = tmp_endpoint.data_;
        -:  163:}
        -:  164:
        -:  165:bool operator==(const endpoint& e1, const endpoint& e2) BOOST_ASIO_NOEXCEPT
        -:  166:{
        -:  167:  return e1.address() == e2.address() && e1.port() == e2.port();
        -:  168:}
        -:  169:
        -:  170:bool operator<(const endpoint& e1, const endpoint& e2) BOOST_ASIO_NOEXCEPT
        -:  171:{
        -:  172:  if (e1.address() < e2.address())
        -:  173:    return true;
        -:  174:  if (e1.address() != e2.address())
        -:  175:    return false;
        -:  176:  return e1.port() < e2.port();
        -:  177:}
        -:  178:
        -:  179:#if !defined(BOOST_ASIO_NO_IOSTREAM)
        -:  180:std::string endpoint::to_string() const
        -:  181:{
        -:  182:  std::ostringstream tmp_os;
        -:  183:  tmp_os.imbue(std::locale::classic());
        -:  184:  if (is_v4())
        -:  185:    tmp_os << address();
        -:  186:  else
        -:  187:    tmp_os << '[' << address() << ']';
        -:  188:  tmp_os << ':' << port();
        -:  189:
        -:  190:  return tmp_os.str();
        -:  191:}
        -:  192:#endif // !defined(BOOST_ASIO_NO_IOSTREAM)
        -:  193:
        -:  194:} // namespace detail
        -:  195:} // namespace ip
        -:  196:} // namespace asio
        -:  197:} // namespace boost
        -:  198:
        -:  199:#include <boost/asio/detail/pop_options.hpp>
        -:  200:
        -:  201:#endif // BOOST_ASIO_IP_DETAIL_IMPL_ENDPOINT_IPP
