        -:    0:Source:/usr/include/boost/asio/detail/reactive_socket_send_op.hpp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/reactive_socket_send_op.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
        -:   12:#define BOOST_ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:#include <boost/asio/detail/bind_handler.hpp>
        -:   20:#include <boost/asio/detail/buffer_sequence_adapter.hpp>
        -:   21:#include <boost/asio/detail/fenced_block.hpp>
        -:   22:#include <boost/asio/detail/memory.hpp>
        -:   23:#include <boost/asio/detail/reactor_op.hpp>
        -:   24:#include <boost/asio/detail/socket_ops.hpp>
        -:   25:
        -:   26:#include <boost/asio/detail/push_options.hpp>
        -:   27:
        -:   28:namespace boost {
        -:   29:namespace asio {
        -:   30:namespace detail {
        -:   31:
        -:   32:template <typename ConstBufferSequence>
        -:   33:class reactive_socket_send_op_base : public reactor_op
        -:   34:{
        -:   35:public:
        1:   36:  reactive_socket_send_op_base(socket_type socket,
        -:   37:      socket_ops::state_type state, const ConstBufferSequence& buffers,
        -:   38:      socket_base::message_flags flags, func_type complete_func)
        -:   39:    : reactor_op(&reactive_socket_send_op_base::do_perform, complete_func),
        -:   40:      socket_(socket),
        -:   41:      state_(state),
        -:   42:      buffers_(buffers),
        1:   43:      flags_(flags)
        1:   43-block  0
        -:   44:  {
        1:   45:  }
        -:   46:
        1:   47:  static status do_perform(reactor_op* base)
        -:   48:  {
        1:   49:    reactive_socket_send_op_base* o(
        -:   50:        static_cast<reactive_socket_send_op_base*>(base));
        -:   51:
        -:   52:    buffer_sequence_adapter<boost::asio::const_buffer,
        1:   53:        ConstBufferSequence> bufs(o->buffers_);
        1:   53-block  0
        -:   54:
        1:   55:    status result = socket_ops::non_blocking_send(o->socket_,
        -:   56:          bufs.buffers(), bufs.count(), o->flags_,
       2*:   57:          o->ec_, o->bytes_transferred_) ? done : not_done;
        1:   57-block  0
        1:   57-block  1
    %%%%%:   57-block  2
        -:   58:
        1:   59:    if (result == done)
        1:   59-block  0
        1:   60:      if ((o->state_ & socket_ops::stream_oriented) != 0)
        1:   60-block  0
        1:   61:        if (o->bytes_transferred_ < bufs.total_size())
        1:   61-block  0
    #####:   62:          result = done_and_exhausted;
    %%%%%:   62-block  0
        -:   63:
        -:   64:    BOOST_ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_send",
        -:   65:          o->ec_, o->bytes_transferred_));
        -:   66:
        1:   67:    return result;
        1:   67-block  0
        1:   67-block  1
        -:   68:  }
        -:   69:
        -:   70:private:
        -:   71:  socket_type socket_;
        -:   72:  socket_ops::state_type state_;
        -:   73:  ConstBufferSequence buffers_;
        -:   74:  socket_base::message_flags flags_;
        -:   75:};
        -:   76:
        -:   77:template <typename ConstBufferSequence, typename Handler, typename IoExecutor>
        -:   78:class reactive_socket_send_op :
        -:   79:  public reactive_socket_send_op_base<ConstBufferSequence>
        -:   80:{
        -:   81:public:
       6*:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient16handleConnectionERKNS_6system10error_codeEEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptr5resetEv:
        3:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
        3:   82-block  0
        1:   82-block  1
        3:   82-block  2
        1:   82-block  3
        1:   82-block  4
        1:   82-block  5
        3:   82-block  6
    $$$$$:   82-block  7
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient17handleWriteHeaderERKNS_6system10error_codeEmEUlSJ_mE0_EENS1_18io_object_executorIS8_EEE3ptr5resetEv:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
    %%%%%:   82-block  1
    %%%%%:   82-block  2
    %%%%%:   82-block  3
    %%%%%:   82-block  4
    %%%%%:   82-block  5
    %%%%%:   82-block  6
    $$$$$:   82-block  7
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient15handleWriteBodyERKNS_6system10error_codeEmEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptr5resetEv:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
    %%%%%:   82-block  1
    %%%%%:   82-block  2
    %%%%%:   82-block  3
    %%%%%:   82-block  4
    %%%%%:   82-block  5
    %%%%%:   82-block  6
    $$$$$:   82-block  7
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient16handleConnectionERKNS_6system10error_codeEEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptrD2Ev:
        2:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
        2:   82-block  0
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient16handleConnectionERKNS_6system10error_codeEEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptr8allocateERSL_:
        1:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
        1:   82-block  0
        1:   82-block  1
        1:   82-block  2
        1:   82-block  3
    $$$$$:   82-block  4
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient17handleWriteHeaderERKNS_6system10error_codeEmEUlSJ_mE0_EENS1_18io_object_executorIS8_EEE3ptrD2Ev:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient17handleWriteHeaderERKNS_6system10error_codeEmEUlSJ_mE0_EENS1_18io_object_executorIS8_EEE3ptr8allocateERSL_:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
    %%%%%:   82-block  1
    %%%%%:   82-block  2
    %%%%%:   82-block  3
    $$$$$:   82-block  4
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient15handleWriteBodyERKNS_6system10error_codeEmEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptrD2Ev:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient15handleWriteBodyERKNS_6system10error_codeEmEUlSJ_mE_EENS1_18io_object_executorIS8_EEE3ptr8allocateERSL_:
    #####:   82:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_send_op);
    %%%%%:   82-block  0
    %%%%%:   82-block  1
    %%%%%:   82-block  2
    %%%%%:   82-block  3
    $$$$$:   82-block  4
------------------
        -:   83:
       1*:   84:  reactive_socket_send_op(socket_type socket, socket_ops::state_type state,
        -:   85:      const ConstBufferSequence& buffers, socket_base::message_flags flags,
        -:   86:      Handler& handler, const IoExecutor& io_ex)
        -:   87:    : reactive_socket_send_op_base<ConstBufferSequence>(socket,
        -:   88:        state, buffers, flags, &reactive_socket_send_op::do_complete),
        -:   89:      handler_(BOOST_ASIO_MOVE_CAST(Handler)(handler)),
       1*:   90:      io_executor_(io_ex)
        -:   91:  {
       1*:   92:    handler_work<Handler, IoExecutor>::start(handler_, io_executor_);
       1*:   93:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient16handleConnectionERKNS_6system10error_codeEEUlSJ_mE_EENS1_18io_object_executorIS8_EEEC2EihRKS3_iRSL_RKSN_:
        1:   84:  reactive_socket_send_op(socket_type socket, socket_ops::state_type state,
        -:   85:      const ConstBufferSequence& buffers, socket_base::message_flags flags,
        -:   86:      Handler& handler, const IoExecutor& io_ex)
        -:   87:    : reactive_socket_send_op_base<ConstBufferSequence>(socket,
        -:   88:        state, buffers, flags, &reactive_socket_send_op::do_complete),
        -:   89:      handler_(BOOST_ASIO_MOVE_CAST(Handler)(handler)),
        1:   90:      io_executor_(io_ex)
        1:   90-block  0
        -:   91:  {
        1:   92:    handler_work<Handler, IoExecutor>::start(handler_, io_executor_);
        1:   93:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient17handleWriteHeaderERKNS_6system10error_codeEmEUlSJ_mE0_EENS1_18io_object_executorIS8_EEEC2EihRKS3_iRSL_RKSN_:
    #####:   84:  reactive_socket_send_op(socket_type socket, socket_ops::state_type state,
        -:   85:      const ConstBufferSequence& buffers, socket_base::message_flags flags,
        -:   86:      Handler& handler, const IoExecutor& io_ex)
        -:   87:    : reactive_socket_send_op_base<ConstBufferSequence>(socket,
        -:   88:        state, buffers, flags, &reactive_socket_send_op::do_complete),
        -:   89:      handler_(BOOST_ASIO_MOVE_CAST(Handler)(handler)),
    #####:   90:      io_executor_(io_ex)
    %%%%%:   90-block  0
        -:   91:  {
    #####:   92:    handler_work<Handler, IoExecutor>::start(handler_, io_executor_);
    #####:   93:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient15handleWriteBodyERKNS_6system10error_codeEmEUlSJ_mE_EENS1_18io_object_executorIS8_EEEC2EihRKS3_iRSL_RKSN_:
    #####:   84:  reactive_socket_send_op(socket_type socket, socket_ops::state_type state,
        -:   85:      const ConstBufferSequence& buffers, socket_base::message_flags flags,
        -:   86:      Handler& handler, const IoExecutor& io_ex)
        -:   87:    : reactive_socket_send_op_base<ConstBufferSequence>(socket,
        -:   88:        state, buffers, flags, &reactive_socket_send_op::do_complete),
        -:   89:      handler_(BOOST_ASIO_MOVE_CAST(Handler)(handler)),
    #####:   90:      io_executor_(io_ex)
    %%%%%:   90-block  0
        -:   91:  {
    #####:   92:    handler_work<Handler, IoExecutor>::start(handler_, io_executor_);
    #####:   93:  }
------------------
        -:   94:
       1*:   95:  static void do_complete(void* owner, operation* base,
        -:   96:      const boost::system::error_code& /*ec*/,
        -:   97:      std::size_t /*bytes_transferred*/)
        -:   98:  {
        -:   99:    // Take ownership of the handler object.
       1*:  100:    reactive_socket_send_op* o(static_cast<reactive_socket_send_op*>(base));
       2*:  101:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
       2*:  102:    handler_work<Handler, IoExecutor> w(o->handler_, o->io_executor_);
        -:  103:
        -:  104:    BOOST_ASIO_HANDLER_COMPLETION((*o));
        -:  105:
        -:  106:    // Make a copy of the handler so that the memory can be deallocated before
        -:  107:    // the upcall is made. Even if we're not about to make an upcall, a
        -:  108:    // sub-object of the handler may be the true owner of the memory associated
        -:  109:    // with the handler. Consequently, a local copy of the handler is required
        -:  110:    // to ensure that any owning sub-object remains valid until after we have
        -:  111:    // deallocated the memory here.
        -:  112:    detail::binder2<Handler, boost::system::error_code, std::size_t>
       1*:  113:      handler(o->handler_, o->ec_, o->bytes_transferred_);
       1*:  114:    p.h = boost::asio::detail::addressof(handler.handler_);
       1*:  115:    p.reset();
        -:  116:
        -:  117:    // Make the upcall if required.
       1*:  118:    if (owner)
        -:  119:    {
       2*:  120:      fenced_block b(fenced_block::half);
        -:  121:      BOOST_ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
       1*:  122:      w.complete(handler, handler.handler_);
        -:  123:      BOOST_ASIO_HANDLER_INVOCATION_END;
        -:  124:    }
       1*:  125:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient16handleConnectionERKNS_6system10error_codeEEUlSJ_mE_EENS1_18io_object_executorIS8_EEE11do_completeEPvPNS1_19scheduler_operationESJ_m:
        1:   95:  static void do_complete(void* owner, operation* base,
        -:   96:      const boost::system::error_code& /*ec*/,
        -:   97:      std::size_t /*bytes_transferred*/)
        -:   98:  {
        -:   99:    // Take ownership of the handler object.
        1:  100:    reactive_socket_send_op* o(static_cast<reactive_socket_send_op*>(base));
        2:  101:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
        1:  101-block  0
    $$$$$:  101-block  1
        2:  102:    handler_work<Handler, IoExecutor> w(o->handler_, o->io_executor_);
        1:  102-block  0
    $$$$$:  102-block  1
        -:  103:
        -:  104:    BOOST_ASIO_HANDLER_COMPLETION((*o));
        -:  105:
        -:  106:    // Make a copy of the handler so that the memory can be deallocated before
        -:  107:    // the upcall is made. Even if we're not about to make an upcall, a
        -:  108:    // sub-object of the handler may be the true owner of the memory associated
        -:  109:    // with the handler. Consequently, a local copy of the handler is required
        -:  110:    // to ensure that any owning sub-object remains valid until after we have
        -:  111:    // deallocated the memory here.
        -:  112:    detail::binder2<Handler, boost::system::error_code, std::size_t>
        1:  113:      handler(o->handler_, o->ec_, o->bytes_transferred_);
        1:  114:    p.h = boost::asio::detail::addressof(handler.handler_);
        1:  115:    p.reset();
        -:  116:
        -:  117:    // Make the upcall if required.
        1:  118:    if (owner)
        1:  118-block  0
        -:  119:    {
        2:  120:      fenced_block b(fenced_block::half);
        1:  120-block  0
        1:  120-block  1
    $$$$$:  120-block  2
        -:  121:      BOOST_ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
        1:  122:      w.complete(handler, handler.handler_);
        -:  123:      BOOST_ASIO_HANDLER_INVOCATION_END;
        -:  124:    }
        1:  125:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient17handleWriteHeaderERKNS_6system10error_codeEmEUlSJ_mE0_EENS1_18io_object_executorIS8_EEE11do_completeEPvPNS1_19scheduler_operationESJ_m:
    #####:   95:  static void do_complete(void* owner, operation* base,
        -:   96:      const boost::system::error_code& /*ec*/,
        -:   97:      std::size_t /*bytes_transferred*/)
        -:   98:  {
        -:   99:    // Take ownership of the handler object.
    #####:  100:    reactive_socket_send_op* o(static_cast<reactive_socket_send_op*>(base));
    #####:  101:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
    %%%%%:  101-block  0
    $$$$$:  101-block  1
    #####:  102:    handler_work<Handler, IoExecutor> w(o->handler_, o->io_executor_);
    %%%%%:  102-block  0
    $$$$$:  102-block  1
        -:  103:
        -:  104:    BOOST_ASIO_HANDLER_COMPLETION((*o));
        -:  105:
        -:  106:    // Make a copy of the handler so that the memory can be deallocated before
        -:  107:    // the upcall is made. Even if we're not about to make an upcall, a
        -:  108:    // sub-object of the handler may be the true owner of the memory associated
        -:  109:    // with the handler. Consequently, a local copy of the handler is required
        -:  110:    // to ensure that any owning sub-object remains valid until after we have
        -:  111:    // deallocated the memory here.
        -:  112:    detail::binder2<Handler, boost::system::error_code, std::size_t>
    #####:  113:      handler(o->handler_, o->ec_, o->bytes_transferred_);
    #####:  114:    p.h = boost::asio::detail::addressof(handler.handler_);
    #####:  115:    p.reset();
        -:  116:
        -:  117:    // Make the upcall if required.
    #####:  118:    if (owner)
    %%%%%:  118-block  0
        -:  119:    {
    #####:  120:      fenced_block b(fenced_block::half);
    %%%%%:  120-block  0
    %%%%%:  120-block  1
    $$$$$:  120-block  2
        -:  121:      BOOST_ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
    #####:  122:      w.complete(handler, handler.handler_);
        -:  123:      BOOST_ASIO_HANDLER_INVOCATION_END;
        -:  124:    }
    #####:  125:  }
------------------
_ZN5boost4asio6detail23reactive_socket_send_opINS0_15const_buffers_1ENS1_8write_opINS0_19basic_stream_socketINS0_2ip3tcpENS0_8executorEEENS0_17mutable_buffers_1EPKNS0_14mutable_bufferENS1_14transfer_all_tEZN18BoostNetworkClient15handleWriteBodyERKNS_6system10error_codeEmEUlSJ_mE_EENS1_18io_object_executorIS8_EEE11do_completeEPvPNS1_19scheduler_operationESJ_m:
    #####:   95:  static void do_complete(void* owner, operation* base,
        -:   96:      const boost::system::error_code& /*ec*/,
        -:   97:      std::size_t /*bytes_transferred*/)
        -:   98:  {
        -:   99:    // Take ownership of the handler object.
    #####:  100:    reactive_socket_send_op* o(static_cast<reactive_socket_send_op*>(base));
    #####:  101:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
    %%%%%:  101-block  0
    $$$$$:  101-block  1
    #####:  102:    handler_work<Handler, IoExecutor> w(o->handler_, o->io_executor_);
    %%%%%:  102-block  0
    $$$$$:  102-block  1
        -:  103:
        -:  104:    BOOST_ASIO_HANDLER_COMPLETION((*o));
        -:  105:
        -:  106:    // Make a copy of the handler so that the memory can be deallocated before
        -:  107:    // the upcall is made. Even if we're not about to make an upcall, a
        -:  108:    // sub-object of the handler may be the true owner of the memory associated
        -:  109:    // with the handler. Consequently, a local copy of the handler is required
        -:  110:    // to ensure that any owning sub-object remains valid until after we have
        -:  111:    // deallocated the memory here.
        -:  112:    detail::binder2<Handler, boost::system::error_code, std::size_t>
    #####:  113:      handler(o->handler_, o->ec_, o->bytes_transferred_);
    #####:  114:    p.h = boost::asio::detail::addressof(handler.handler_);
    #####:  115:    p.reset();
        -:  116:
        -:  117:    // Make the upcall if required.
    #####:  118:    if (owner)
    %%%%%:  118-block  0
        -:  119:    {
    #####:  120:      fenced_block b(fenced_block::half);
    %%%%%:  120-block  0
    %%%%%:  120-block  1
    $$$$$:  120-block  2
        -:  121:      BOOST_ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_, handler.arg2_));
    #####:  122:      w.complete(handler, handler.handler_);
        -:  123:      BOOST_ASIO_HANDLER_INVOCATION_END;
        -:  124:    }
    #####:  125:  }
------------------
        -:  126:
        -:  127:private:
        -:  128:  Handler handler_;
        -:  129:  IoExecutor io_executor_;
        -:  130:};
        -:  131:
        -:  132:} // namespace detail
        -:  133:} // namespace asio
        -:  134:} // namespace boost
        -:  135:
        -:  136:#include <boost/asio/detail/pop_options.hpp>
        -:  137:
        -:  138:#endif // BOOST_ASIO_DETAIL_REACTIVE_SOCKET_SEND_OP_HPP
