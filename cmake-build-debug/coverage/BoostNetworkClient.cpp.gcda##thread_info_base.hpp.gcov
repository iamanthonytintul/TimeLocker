        -:    0:Source:/usr/include/boost/asio/detail/thread_info_base.hpp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/thread_info_base.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_THREAD_INFO_BASE_HPP
        -:   12:#define BOOST_ASIO_DETAIL_THREAD_INFO_BASE_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <climits>
        -:   19:#include <cstddef>
        -:   20:#include <boost/asio/detail/noncopyable.hpp>
        -:   21:
        -:   22:#include <boost/asio/detail/push_options.hpp>
        -:   23:
        -:   24:namespace boost {
        -:   25:namespace asio {
        -:   26:namespace detail {
        -:   27:
        -:   28:class thread_info_base
        -:   29:  : private noncopyable
        -:   30:{
        -:   31:public:
        -:   32:  struct default_tag
        -:   33:  {
        -:   34:    enum { mem_index = 0 };
        -:   35:  };
        -:   36:
        -:   37:  struct awaitable_frame_tag
        -:   38:  {
        -:   39:    enum { mem_index = 1 };
        -:   40:  };
        -:   41:
        -:   42:  struct executor_function_tag
        -:   43:  {
        -:   44:    enum { mem_index = 2 };
        -:   45:  };
        -:   46:
    #####:   47:  thread_info_base()
    #####:   48:  {
    %%%%%:   48-block  0
    #####:   49:    for (int i = 0; i < max_mem_index; ++i)
    %%%%%:   49-block  0
    #####:   50:      reusable_memory_[i] = 0;
    %%%%%:   50-block  0
    #####:   51:  }
        -:   52:
    #####:   53:  ~thread_info_base()
    #####:   54:  {
    %%%%%:   54-block  0
    #####:   55:    for (int i = 0; i < max_mem_index; ++i)
    %%%%%:   55-block  0
    %%%%%:   55-block  1
    #####:   56:      ::operator delete(reusable_memory_[i]);
    %%%%%:   56-block  0
    #####:   57:  }
        -:   58:
        4:   59:  static void* allocate(thread_info_base* this_thread, std::size_t size)
        -:   60:  {
        4:   61:    return allocate(default_tag(), this_thread, size);
        4:   61-block  0
        -:   62:  }
        -:   63:
        4:   64:  static void deallocate(thread_info_base* this_thread,
        -:   65:      void* pointer, std::size_t size)
        -:   66:  {
        4:   67:    deallocate(default_tag(), this_thread, pointer, size);
        4:   67-block  0
        4:   68:  }
        -:   69:
        -:   70:  template <typename Purpose>
    #####:   71:  static void* allocate(Purpose, thread_info_base* this_thread,
        -:   72:      std::size_t size)
        -:   73:  {
    #####:   74:    std::size_t chunks = (size + chunk_size - 1) / chunk_size;
        -:   75:
    #####:   76:    if (this_thread && this_thread->reusable_memory_[Purpose::mem_index])
        -:   77:    {
    #####:   78:      void* const pointer = this_thread->reusable_memory_[Purpose::mem_index];
    #####:   79:      this_thread->reusable_memory_[Purpose::mem_index] = 0;
        -:   80:
    #####:   81:      unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   82:      if (static_cast<std::size_t>(mem[0]) >= chunks)
        -:   83:      {
    #####:   84:        mem[size] = mem[0];
    #####:   85:        return pointer;
        -:   86:      }
        -:   87:
    #####:   88:      ::operator delete(pointer);
        -:   89:    }
        -:   90:
    #####:   91:    void* const pointer = ::operator new(chunks * chunk_size + 1);
    #####:   92:    unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   93:    mem[size] = (chunks <= UCHAR_MAX) ? static_cast<unsigned char>(chunks) : 0;
    #####:   94:    return pointer;
        -:   95:  }
------------------
_ZN5boost4asio6detail16thread_info_base8allocateINS2_21executor_function_tagEEEPvT_PS2_m:
    #####:   71:  static void* allocate(Purpose, thread_info_base* this_thread,
        -:   72:      std::size_t size)
        -:   73:  {
    #####:   74:    std::size_t chunks = (size + chunk_size - 1) / chunk_size;
        -:   75:
    #####:   76:    if (this_thread && this_thread->reusable_memory_[Purpose::mem_index])
    %%%%%:   76-block  0
    %%%%%:   76-block  1
        -:   77:    {
    #####:   78:      void* const pointer = this_thread->reusable_memory_[Purpose::mem_index];
    #####:   79:      this_thread->reusable_memory_[Purpose::mem_index] = 0;
        -:   80:
    #####:   81:      unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   82:      if (static_cast<std::size_t>(mem[0]) >= chunks)
    %%%%%:   82-block  0
        -:   83:      {
    #####:   84:        mem[size] = mem[0];
    #####:   85:        return pointer;
    %%%%%:   85-block  0
        -:   86:      }
        -:   87:
    #####:   88:      ::operator delete(pointer);
    %%%%%:   88-block  0
        -:   89:    }
        -:   90:
    #####:   91:    void* const pointer = ::operator new(chunks * chunk_size + 1);
    %%%%%:   91-block  0
    #####:   92:    unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   93:    mem[size] = (chunks <= UCHAR_MAX) ? static_cast<unsigned char>(chunks) : 0;
    %%%%%:   93-block  0
    %%%%%:   93-block  1
    #####:   94:    return pointer;
    %%%%%:   94-block  0
        -:   95:  }
------------------
_ZN5boost4asio6detail16thread_info_base8allocateINS2_11default_tagEEEPvT_PS2_m:
    #####:   71:  static void* allocate(Purpose, thread_info_base* this_thread,
        -:   72:      std::size_t size)
        -:   73:  {
    #####:   74:    std::size_t chunks = (size + chunk_size - 1) / chunk_size;
        -:   75:
    #####:   76:    if (this_thread && this_thread->reusable_memory_[Purpose::mem_index])
    %%%%%:   76-block  0
    %%%%%:   76-block  1
        -:   77:    {
    #####:   78:      void* const pointer = this_thread->reusable_memory_[Purpose::mem_index];
    #####:   79:      this_thread->reusable_memory_[Purpose::mem_index] = 0;
        -:   80:
    #####:   81:      unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   82:      if (static_cast<std::size_t>(mem[0]) >= chunks)
    %%%%%:   82-block  0
        -:   83:      {
    #####:   84:        mem[size] = mem[0];
    #####:   85:        return pointer;
    %%%%%:   85-block  0
        -:   86:      }
        -:   87:
    #####:   88:      ::operator delete(pointer);
    %%%%%:   88-block  0
        -:   89:    }
        -:   90:
    #####:   91:    void* const pointer = ::operator new(chunks * chunk_size + 1);
    %%%%%:   91-block  0
    #####:   92:    unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:   93:    mem[size] = (chunks <= UCHAR_MAX) ? static_cast<unsigned char>(chunks) : 0;
    %%%%%:   93-block  0
    %%%%%:   93-block  1
    #####:   94:    return pointer;
    %%%%%:   94-block  0
        -:   95:  }
------------------
        -:   96:
        -:   97:  template <typename Purpose>
    #####:   98:  static void deallocate(Purpose, thread_info_base* this_thread,
        -:   99:      void* pointer, std::size_t size)
        -:  100:  {
    #####:  101:    if (size <= chunk_size * UCHAR_MAX)
        -:  102:    {
    #####:  103:      if (this_thread && this_thread->reusable_memory_[Purpose::mem_index] == 0)
        -:  104:      {
    #####:  105:        unsigned char* const mem = static_cast<unsigned char*>(pointer);
    #####:  106:        mem[0] = mem[size];
    #####:  107:        this_thread->reusable_memory_[Purpose::mem_index] = pointer;
    #####:  108:        return;
        -:  109:      }
        -:  110:    }
        -:  111:
    #####:  112:    ::operator delete(pointer);
        -:  113:  }
        -:  114:
        -:  115:private:
        -:  116:  enum { chunk_size = 4 };
        -:  117:  enum { max_mem_index = 3 };
        -:  118:  void* reusable_memory_[max_mem_index];
        -:  119:};
        -:  120:
        -:  121:} // namespace detail
        -:  122:} // namespace asio
        -:  123:} // namespace boost
        -:  124:
        -:  125:#include <boost/asio/detail/pop_options.hpp>
        -:  126:
        -:  127:#endif // BOOST_ASIO_DETAIL_THREAD_INFO_BASE_HPP
