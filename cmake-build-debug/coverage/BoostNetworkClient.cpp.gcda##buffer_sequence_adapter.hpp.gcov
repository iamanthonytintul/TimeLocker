        -:    0:Source:/usr/include/boost/asio/detail/buffer_sequence_adapter.hpp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/buffer_sequence_adapter.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
        -:   12:#define BOOST_ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:#include <boost/asio/buffer.hpp>
        -:   20:#include <boost/asio/detail/array_fwd.hpp>
        -:   21:#include <boost/asio/detail/socket_types.hpp>
        -:   22:
        -:   23:#include <boost/asio/detail/push_options.hpp>
        -:   24:
        -:   25:namespace boost {
        -:   26:namespace asio {
        -:   27:namespace detail {
        -:   28:
        -:   29:class buffer_sequence_adapter_base
        -:   30:{
        -:   31:#if defined(BOOST_ASIO_WINDOWS_RUNTIME)
        -:   32:public:
        -:   33:  // The maximum number of buffers to support in a single operation.
        -:   34:  enum { max_buffers = 1 };
        -:   35:
        -:   36:protected:
        -:   37:  typedef Windows::Storage::Streams::IBuffer^ native_buffer_type;
        -:   38:
        -:   39:  BOOST_ASIO_DECL static void init_native_buffer(
        -:   40:      native_buffer_type& buffer,
        -:   41:      const boost::asio::mutable_buffer& buffer);
        -:   42:
        -:   43:  BOOST_ASIO_DECL static void init_native_buffer(
        -:   44:      native_buffer_type& buffer,
        -:   45:      const boost::asio::const_buffer& buffer);
        -:   46:#elif defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   47:public:
        -:   48:  // The maximum number of buffers to support in a single operation.
        -:   49:  enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
        -:   50:
        -:   51:protected:
        -:   52:  typedef WSABUF native_buffer_type;
        -:   53:
        -:   54:  static void init_native_buffer(WSABUF& buffer,
        -:   55:      const boost::asio::mutable_buffer& buffer)
        -:   56:  {
        -:   57:    buffer.buffer = static_cast<char*>(buffer.data());
        -:   58:    buffer.len = static_cast<ULONG>(buffer.size());
        -:   59:  }
        -:   60:
        -:   61:  static void init_native_buffer(WSABUF& buffer,
        -:   62:      const boost::asio::const_buffer& buffer)
        -:   63:  {
        -:   64:    buffer.buffer = const_cast<char*>(static_cast<const char*>(buffer.data()));
        -:   65:    buffer.len = static_cast<ULONG>(buffer.size());
        -:   66:  }
        -:   67:#else // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:   68:public:
        -:   69:  // The maximum number of buffers to support in a single operation.
        -:   70:  enum { max_buffers = 64 < max_iov_len ? 64 : max_iov_len };
        -:   71:
        -:   72:protected:
        -:   73:  typedef iovec native_buffer_type;
        -:   74:
        4:   75:  static void init_iov_base(void*& base, void* addr)
        -:   76:  {
        4:   77:    base = addr;
        4:   78:  }
        -:   79:
        -:   80:  template <typename T>
        -:   81:  static void init_iov_base(T& base, void* addr)
        -:   82:  {
        -:   83:    base = static_cast<T>(addr);
        -:   84:  }
        -:   85:
        3:   86:  static void init_native_buffer(iovec& iov,
        -:   87:      const boost::asio::mutable_buffer& buffer)
        -:   88:  {
        3:   89:    init_iov_base(iov.iov_base, buffer.data());
        3:   89-block  0
        3:   90:    iov.iov_len = buffer.size();
        3:   91:  }
        -:   92:
        1:   93:  static void init_native_buffer(iovec& iov,
        -:   94:      const boost::asio::const_buffer& buffer)
        -:   95:  {
        1:   96:    init_iov_base(iov.iov_base, const_cast<void*>(buffer.data()));
        1:   96-block  0
        1:   97:    iov.iov_len = buffer.size();
        1:   98:  }
        -:   99:#endif // defined(BOOST_ASIO_WINDOWS) || defined(__CYGWIN__)
        -:  100:};
        -:  101:
        -:  102:// Helper class to translate buffers into the native buffer representation.
        -:  103:template <typename Buffer, typename Buffers>
        -:  104:class buffer_sequence_adapter
        -:  105:  : buffer_sequence_adapter_base
        -:  106:{
        -:  107:public:
        -:  108:  explicit buffer_sequence_adapter(const Buffers& buffer_sequence)
        -:  109:    : count_(0), total_buffer_size_(0)
        -:  110:  {
        -:  111:    buffer_sequence_adapter::init(
        -:  112:        boost::asio::buffer_sequence_begin(buffer_sequence),
        -:  113:        boost::asio::buffer_sequence_end(buffer_sequence));
        -:  114:  }
        -:  115:
        -:  116:  native_buffer_type* buffers()
        -:  117:  {
        -:  118:    return buffers_;
        -:  119:  }
        -:  120:
        -:  121:  std::size_t count() const
        -:  122:  {
        -:  123:    return count_;
        -:  124:  }
        -:  125:
        -:  126:  std::size_t total_size() const
        -:  127:  {
        -:  128:    return total_buffer_size_;
        -:  129:  }
        -:  130:
        -:  131:  bool all_empty() const
        -:  132:  {
        -:  133:    return total_buffer_size_ == 0;
        -:  134:  }
        -:  135:
        -:  136:  static bool all_empty(const Buffers& buffer_sequence)
        -:  137:  {
        -:  138:    return buffer_sequence_adapter::all_empty(
        -:  139:        boost::asio::buffer_sequence_begin(buffer_sequence),
        -:  140:        boost::asio::buffer_sequence_end(buffer_sequence));
        -:  141:  }
        -:  142:
        -:  143:  static void validate(const Buffers& buffer_sequence)
        -:  144:  {
        -:  145:    buffer_sequence_adapter::validate(
        -:  146:        boost::asio::buffer_sequence_begin(buffer_sequence),
        -:  147:        boost::asio::buffer_sequence_end(buffer_sequence));
        -:  148:  }
        -:  149:
        -:  150:  static Buffer first(const Buffers& buffer_sequence)
        -:  151:  {
        -:  152:    return buffer_sequence_adapter::first(
        -:  153:        boost::asio::buffer_sequence_begin(buffer_sequence),
        -:  154:        boost::asio::buffer_sequence_end(buffer_sequence));
        -:  155:  }
        -:  156:
        -:  157:private:
        -:  158:  template <typename Iterator>
        -:  159:  void init(Iterator begin, Iterator end)
        -:  160:  {
        -:  161:    Iterator iter = begin;
        -:  162:    for (; iter != end && count_ < max_buffers; ++iter, ++count_)
        -:  163:    {
        -:  164:      Buffer buffer(*iter);
        -:  165:      init_native_buffer(buffers_[count_], buffer);
        -:  166:      total_buffer_size_ += buffer.size();
        -:  167:    }
        -:  168:  }
        -:  169:
        -:  170:  template <typename Iterator>
        -:  171:  static bool all_empty(Iterator begin, Iterator end)
        -:  172:  {
        -:  173:    Iterator iter = begin;
        -:  174:    std::size_t i = 0;
        -:  175:    for (; iter != end && i < max_buffers; ++iter, ++i)
        -:  176:      if (Buffer(*iter).size() > 0)
        -:  177:        return false;
        -:  178:    return true;
        -:  179:  }
        -:  180:
        -:  181:  template <typename Iterator>
        -:  182:  static void validate(Iterator begin, Iterator end)
        -:  183:  {
        -:  184:    Iterator iter = begin;
        -:  185:    for (; iter != end; ++iter)
        -:  186:    {
        -:  187:      Buffer buffer(*iter);
        -:  188:      buffer.data();
        -:  189:    }
        -:  190:  }
        -:  191:
        -:  192:  template <typename Iterator>
        -:  193:  static Buffer first(Iterator begin, Iterator end)
        -:  194:  {
        -:  195:    Iterator iter = begin;
        -:  196:    for (; iter != end; ++iter)
        -:  197:    {
        -:  198:      Buffer buffer(*iter);
        -:  199:      if (buffer.size() != 0)
        -:  200:        return buffer;
        -:  201:    }
        -:  202:    return Buffer();
        -:  203:  }
        -:  204:
        -:  205:  native_buffer_type buffers_[max_buffers];
        -:  206:  std::size_t count_;
        -:  207:  std::size_t total_buffer_size_;
        -:  208:};
        -:  209:
        -:  210:template <typename Buffer>
        -:  211:class buffer_sequence_adapter<Buffer, boost::asio::mutable_buffer>
        -:  212:  : buffer_sequence_adapter_base
        -:  213:{
        -:  214:public:
        -:  215:  explicit buffer_sequence_adapter(
        -:  216:      const boost::asio::mutable_buffer& buffer_sequence)
        -:  217:  {
        -:  218:    init_native_buffer(buffer_, Buffer(buffer_sequence));
        -:  219:    total_buffer_size_ = buffer_sequence.size();
        -:  220:  }
        -:  221:
        -:  222:  native_buffer_type* buffers()
        -:  223:  {
        -:  224:    return &buffer_;
        -:  225:  }
        -:  226:
        -:  227:  std::size_t count() const
        -:  228:  {
        -:  229:    return 1;
        -:  230:  }
        -:  231:
        -:  232:  std::size_t total_size() const
        -:  233:  {
        -:  234:    return total_buffer_size_;
        -:  235:  }
        -:  236:
        -:  237:  bool all_empty() const
        -:  238:  {
        -:  239:    return total_buffer_size_ == 0;
        -:  240:  }
        -:  241:
        -:  242:  static bool all_empty(const boost::asio::mutable_buffer& buffer_sequence)
        -:  243:  {
        -:  244:    return buffer_sequence.size() == 0;
        -:  245:  }
        -:  246:
        -:  247:  static void validate(const boost::asio::mutable_buffer& buffer_sequence)
        -:  248:  {
        -:  249:    buffer_sequence.data();
        -:  250:  }
        -:  251:
        -:  252:  static Buffer first(const boost::asio::mutable_buffer& buffer_sequence)
        -:  253:  {
        -:  254:    return Buffer(buffer_sequence);
        -:  255:  }
        -:  256:
        -:  257:private:
        -:  258:  native_buffer_type buffer_;
        -:  259:  std::size_t total_buffer_size_;
        -:  260:};
        -:  261:
        -:  262:template <typename Buffer>
        -:  263:class buffer_sequence_adapter<Buffer, boost::asio::const_buffer>
        -:  264:  : buffer_sequence_adapter_base
        -:  265:{
        -:  266:public:
        -:  267:  explicit buffer_sequence_adapter(
        -:  268:      const boost::asio::const_buffer& buffer_sequence)
        -:  269:  {
        -:  270:    init_native_buffer(buffer_, Buffer(buffer_sequence));
        -:  271:    total_buffer_size_ = buffer_sequence.size();
        -:  272:  }
        -:  273:
        -:  274:  native_buffer_type* buffers()
        -:  275:  {
        -:  276:    return &buffer_;
        -:  277:  }
        -:  278:
        -:  279:  std::size_t count() const
        -:  280:  {
        -:  281:    return 1;
        -:  282:  }
        -:  283:
        -:  284:  std::size_t total_size() const
        -:  285:  {
        -:  286:    return total_buffer_size_;
        -:  287:  }
        -:  288:
        -:  289:  bool all_empty() const
        -:  290:  {
        -:  291:    return total_buffer_size_ == 0;
        -:  292:  }
        -:  293:
        -:  294:  static bool all_empty(const boost::asio::const_buffer& buffer_sequence)
        -:  295:  {
        -:  296:    return buffer_sequence.size() == 0;
        -:  297:  }
        -:  298:
        -:  299:  static void validate(const boost::asio::const_buffer& buffer_sequence)
        -:  300:  {
        -:  301:    buffer_sequence.data();
        -:  302:  }
        -:  303:
        -:  304:  static Buffer first(const boost::asio::const_buffer& buffer_sequence)
        -:  305:  {
        -:  306:    return Buffer(buffer_sequence);
        -:  307:  }
        -:  308:
        -:  309:private:
        -:  310:  native_buffer_type buffer_;
        -:  311:  std::size_t total_buffer_size_;
        -:  312:};
        -:  313:
        -:  314:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  315:
        -:  316:template <typename Buffer>
        -:  317:class buffer_sequence_adapter<Buffer, boost::asio::mutable_buffers_1>
        -:  318:  : buffer_sequence_adapter_base
        -:  319:{
        -:  320:public:
        3:  321:  explicit buffer_sequence_adapter(
        -:  322:      const boost::asio::mutable_buffers_1& buffer_sequence)
        -:  323:  {
        3:  324:    init_native_buffer(buffer_, Buffer(buffer_sequence));
        3:  324-block  0
        3:  325:    total_buffer_size_ = buffer_sequence.size();
        3:  326:  }
        -:  327:
        3:  328:  native_buffer_type* buffers()
        -:  329:  {
        3:  330:    return &buffer_;
        3:  330-block  0
        -:  331:  }
        -:  332:
        3:  333:  std::size_t count() const
        -:  334:  {
        3:  335:    return 1;
        3:  335-block  0
        -:  336:  }
        -:  337:
        -:  338:  std::size_t total_size() const
        -:  339:  {
        -:  340:    return total_buffer_size_;
        -:  341:  }
        -:  342:
        -:  343:  bool all_empty() const
        -:  344:  {
        -:  345:    return total_buffer_size_ == 0;
        -:  346:  }
        -:  347:
        2:  348:  static bool all_empty(const boost::asio::mutable_buffers_1& buffer_sequence)
        -:  349:  {
        2:  350:    return buffer_sequence.size() == 0;
        2:  350-block  0
        -:  351:  }
        -:  352:
        -:  353:  static void validate(const boost::asio::mutable_buffers_1& buffer_sequence)
        -:  354:  {
        -:  355:    buffer_sequence.data();
        -:  356:  }
        -:  357:
        -:  358:  static Buffer first(const boost::asio::mutable_buffers_1& buffer_sequence)
        -:  359:  {
        -:  360:    return Buffer(buffer_sequence);
        -:  361:  }
        -:  362:
        -:  363:private:
        -:  364:  native_buffer_type buffer_;
        -:  365:  std::size_t total_buffer_size_;
        -:  366:};
        -:  367:
        -:  368:template <typename Buffer>
        -:  369:class buffer_sequence_adapter<Buffer, boost::asio::const_buffers_1>
        -:  370:  : buffer_sequence_adapter_base
        -:  371:{
        -:  372:public:
        1:  373:  explicit buffer_sequence_adapter(
        -:  374:      const boost::asio::const_buffers_1& buffer_sequence)
        -:  375:  {
        1:  376:    init_native_buffer(buffer_, Buffer(buffer_sequence));
        1:  376-block  0
        1:  377:    total_buffer_size_ = buffer_sequence.size();
        1:  378:  }
        -:  379:
        1:  380:  native_buffer_type* buffers()
        -:  381:  {
        1:  382:    return &buffer_;
        1:  382-block  0
        -:  383:  }
        -:  384:
        1:  385:  std::size_t count() const
        -:  386:  {
        1:  387:    return 1;
        1:  387-block  0
        -:  388:  }
        -:  389:
        1:  390:  std::size_t total_size() const
        -:  391:  {
        1:  392:    return total_buffer_size_;
        1:  392-block  0
        -:  393:  }
        -:  394:
        -:  395:  bool all_empty() const
        -:  396:  {
        -:  397:    return total_buffer_size_ == 0;
        -:  398:  }
        -:  399:
        1:  400:  static bool all_empty(const boost::asio::const_buffers_1& buffer_sequence)
        -:  401:  {
        1:  402:    return buffer_sequence.size() == 0;
        1:  402-block  0
        -:  403:  }
        -:  404:
        -:  405:  static void validate(const boost::asio::const_buffers_1& buffer_sequence)
        -:  406:  {
        -:  407:    buffer_sequence.data();
        -:  408:  }
        -:  409:
        -:  410:  static Buffer first(const boost::asio::const_buffers_1& buffer_sequence)
        -:  411:  {
        -:  412:    return Buffer(buffer_sequence);
        -:  413:  }
        -:  414:
        -:  415:private:
        -:  416:  native_buffer_type buffer_;
        -:  417:  std::size_t total_buffer_size_;
        -:  418:};
        -:  419:
        -:  420:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  421:
        -:  422:template <typename Buffer, typename Elem>
        -:  423:class buffer_sequence_adapter<Buffer, boost::array<Elem, 2> >
        -:  424:  : buffer_sequence_adapter_base
        -:  425:{
        -:  426:public:
        -:  427:  explicit buffer_sequence_adapter(
        -:  428:      const boost::array<Elem, 2>& buffer_sequence)
        -:  429:  {
        -:  430:    init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
        -:  431:    init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
        -:  432:    total_buffer_size_ = buffer_sequence[0].size() + buffer_sequence[1].size();
        -:  433:  }
        -:  434:
        -:  435:  native_buffer_type* buffers()
        -:  436:  {
        -:  437:    return buffers_;
        -:  438:  }
        -:  439:
        -:  440:  std::size_t count() const
        -:  441:  {
        -:  442:    return 2;
        -:  443:  }
        -:  444:
        -:  445:  std::size_t total_size() const
        -:  446:  {
        -:  447:    return total_buffer_size_;
        -:  448:  }
        -:  449:
        -:  450:  bool all_empty() const
        -:  451:  {
        -:  452:    return total_buffer_size_ == 0;
        -:  453:  }
        -:  454:
        -:  455:  static bool all_empty(const boost::array<Elem, 2>& buffer_sequence)
        -:  456:  {
        -:  457:    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;
        -:  458:  }
        -:  459:
        -:  460:  static void validate(const boost::array<Elem, 2>& buffer_sequence)
        -:  461:  {
        -:  462:    buffer_sequence[0].data();
        -:  463:    buffer_sequence[1].data();
        -:  464:  }
        -:  465:
        -:  466:  static Buffer first(const boost::array<Elem, 2>& buffer_sequence)
        -:  467:  {
        -:  468:    return Buffer(buffer_sequence[0].size() != 0
        -:  469:        ? buffer_sequence[0] : buffer_sequence[1]);
        -:  470:  }
        -:  471:
        -:  472:private:
        -:  473:  native_buffer_type buffers_[2];
        -:  474:  std::size_t total_buffer_size_;
        -:  475:};
        -:  476:
        -:  477:#if defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:  478:
        -:  479:template <typename Buffer, typename Elem>
        -:  480:class buffer_sequence_adapter<Buffer, std::array<Elem, 2> >
        -:  481:  : buffer_sequence_adapter_base
        -:  482:{
        -:  483:public:
        -:  484:  explicit buffer_sequence_adapter(
        -:  485:      const std::array<Elem, 2>& buffer_sequence)
        -:  486:  {
        -:  487:    init_native_buffer(buffers_[0], Buffer(buffer_sequence[0]));
        -:  488:    init_native_buffer(buffers_[1], Buffer(buffer_sequence[1]));
        -:  489:    total_buffer_size_ = buffer_sequence[0].size() + buffer_sequence[1].size();
        -:  490:  }
        -:  491:
        -:  492:  native_buffer_type* buffers()
        -:  493:  {
        -:  494:    return buffers_;
        -:  495:  }
        -:  496:
        -:  497:  std::size_t count() const
        -:  498:  {
        -:  499:    return 2;
        -:  500:  }
        -:  501:
        -:  502:  std::size_t total_size() const
        -:  503:  {
        -:  504:    return total_buffer_size_;
        -:  505:  }
        -:  506:
        -:  507:  bool all_empty() const
        -:  508:  {
        -:  509:    return total_buffer_size_ == 0;
        -:  510:  }
        -:  511:
        -:  512:  static bool all_empty(const std::array<Elem, 2>& buffer_sequence)
        -:  513:  {
        -:  514:    return buffer_sequence[0].size() == 0 && buffer_sequence[1].size() == 0;
        -:  515:  }
        -:  516:
        -:  517:  static void validate(const std::array<Elem, 2>& buffer_sequence)
        -:  518:  {
        -:  519:    buffer_sequence[0].data();
        -:  520:    buffer_sequence[1].data();
        -:  521:  }
        -:  522:
        -:  523:  static Buffer first(const std::array<Elem, 2>& buffer_sequence)
        -:  524:  {
        -:  525:    return Buffer(buffer_sequence[0].size() != 0
        -:  526:        ? buffer_sequence[0] : buffer_sequence[1]);
        -:  527:  }
        -:  528:
        -:  529:private:
        -:  530:  native_buffer_type buffers_[2];
        -:  531:  std::size_t total_buffer_size_;
        -:  532:};
        -:  533:
        -:  534:#endif // defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:  535:
        -:  536:} // namespace detail
        -:  537:} // namespace asio
        -:  538:} // namespace boost
        -:  539:
        -:  540:#include <boost/asio/detail/pop_options.hpp>
        -:  541:
        -:  542:#if defined(BOOST_ASIO_HEADER_ONLY)
        -:  543:# include <boost/asio/detail/impl/buffer_sequence_adapter.ipp>
        -:  544:#endif // defined(BOOST_ASIO_HEADER_ONLY)
        -:  545:
        -:  546:#endif // BOOST_ASIO_DETAIL_BUFFER_SEQUENCE_ADAPTER_HPP
