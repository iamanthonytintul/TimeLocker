        -:    0:Source:/usr/include/boost/asio/ip/impl/address_v6.ipp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// ip/impl/address_v6.ipp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_IP_IMPL_ADDRESS_V6_IPP
        -:   12:#define BOOST_ASIO_IP_IMPL_ADDRESS_V6_IPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:#include <cstring>
        -:   20:#include <stdexcept>
        -:   21:#include <typeinfo>
        -:   22:#include <boost/asio/detail/socket_ops.hpp>
        -:   23:#include <boost/asio/detail/throw_error.hpp>
        -:   24:#include <boost/asio/detail/throw_exception.hpp>
        -:   25:#include <boost/asio/error.hpp>
        -:   26:#include <boost/asio/ip/address_v6.hpp>
        -:   27:#include <boost/asio/ip/bad_address_cast.hpp>
        -:   28:
        -:   29:#include <boost/asio/detail/push_options.hpp>
        -:   30:
        -:   31:namespace boost {
        -:   32:namespace asio {
        -:   33:namespace ip {
        -:   34:
        2:   35:address_v6::address_v6() BOOST_ASIO_NOEXCEPT
        -:   36:  : addr_(),
        2:   37:    scope_id_(0)
        -:   38:{
        2:   39:}
        -:   40:
    #####:   41:address_v6::address_v6(const address_v6::bytes_type& bytes,
    #####:   42:    unsigned long scope)
    #####:   43:  : scope_id_(scope)
        -:   44:{
        -:   45:#if UCHAR_MAX > 0xFF
        -:   46:  for (std::size_t i = 0; i < bytes.size(); ++i)
        -:   47:  {
        -:   48:    if (bytes[i] > 0xFF)
        -:   49:    {
        -:   50:      std::out_of_range ex("address_v6 from bytes_type");
        -:   51:      boost::asio::detail::throw_exception(ex);
        -:   52:    }
        -:   53:  }
        -:   54:#endif // UCHAR_MAX > 0xFF
        -:   55:
        -:   56:  using namespace std; // For memcpy.
    #####:   57:  memcpy(addr_.s6_addr, bytes.data(), 16);
    %%%%%:   57-block  0
    #####:   58:}
        -:   59:
    #####:   60:address_v6::address_v6(const address_v6& other) BOOST_ASIO_NOEXCEPT
        -:   61:  : addr_(other.addr_),
    #####:   62:    scope_id_(other.scope_id_)
        -:   63:{
    #####:   64:}
        -:   65:
        -:   66:#if defined(BOOST_ASIO_HAS_MOVE)
        -:   67:address_v6::address_v6(address_v6&& other) BOOST_ASIO_NOEXCEPT
        -:   68:  : addr_(other.addr_),
        -:   69:    scope_id_(other.scope_id_)
        -:   70:{
        -:   71:}
        -:   72:#endif // defined(BOOST_ASIO_HAS_MOVE)
        -:   73:
        -:   74:address_v6& address_v6::operator=(const address_v6& other) BOOST_ASIO_NOEXCEPT
        -:   75:{
        -:   76:  addr_ = other.addr_;
        -:   77:  scope_id_ = other.scope_id_;
        -:   78:  return *this;
        -:   79:}
        -:   80:
        -:   81:#if defined(BOOST_ASIO_HAS_MOVE)
        -:   82:address_v6& address_v6::operator=(address_v6&& other) BOOST_ASIO_NOEXCEPT
        -:   83:{
        -:   84:  addr_ = other.addr_;
        -:   85:  scope_id_ = other.scope_id_;
        -:   86:  return *this;
        -:   87:}
        -:   88:#endif // defined(BOOST_ASIO_HAS_MOVE)
        -:   89:
    #####:   90:address_v6::bytes_type address_v6::to_bytes() const BOOST_ASIO_NOEXCEPT
        -:   91:{
        -:   92:  using namespace std; // For memcpy.
        -:   93:  bytes_type bytes;
        -:   94:#if defined(BOOST_ASIO_HAS_STD_ARRAY)
    #####:   95:  memcpy(bytes.data(), addr_.s6_addr, 16);
    %%%%%:   95-block  0
        -:   96:#else // defined(BOOST_ASIO_HAS_STD_ARRAY)
        -:   97:  memcpy(bytes.elems, addr_.s6_addr, 16);
        -:   98:#endif // defined(BOOST_ASIO_HAS_STD_ARRAY)
    #####:   99:  return bytes;
        -:  100:}
        -:  101:
        -:  102:std::string address_v6::to_string() const
        -:  103:{
        -:  104:  boost::system::error_code ec;
        -:  105:  char addr_str[boost::asio::detail::max_addr_v6_str_len];
        -:  106:  const char* addr =
        -:  107:    boost::asio::detail::socket_ops::inet_ntop(
        -:  108:        BOOST_ASIO_OS_DEF(AF_INET6), &addr_, addr_str,
        -:  109:        boost::asio::detail::max_addr_v6_str_len, scope_id_, ec);
        -:  110:  if (addr == 0)
        -:  111:    boost::asio::detail::throw_error(ec);
        -:  112:  return addr;
        -:  113:}
        -:  114:
        -:  115:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  116:std::string address_v6::to_string(boost::system::error_code& ec) const
        -:  117:{
        -:  118:  char addr_str[boost::asio::detail::max_addr_v6_str_len];
        -:  119:  const char* addr =
        -:  120:    boost::asio::detail::socket_ops::inet_ntop(
        -:  121:        BOOST_ASIO_OS_DEF(AF_INET6), &addr_, addr_str,
        -:  122:        boost::asio::detail::max_addr_v6_str_len, scope_id_, ec);
        -:  123:  if (addr == 0)
        -:  124:    return std::string();
        -:  125:  return addr;
        -:  126:}
        -:  127:
        -:  128:address_v4 address_v6::to_v4() const
        -:  129:{
        -:  130:  if (!is_v4_mapped() && !is_v4_compatible())
        -:  131:  {
        -:  132:    bad_address_cast ex;
        -:  133:    boost::asio::detail::throw_exception(ex);
        -:  134:  }
        -:  135:
        -:  136:  address_v4::bytes_type v4_bytes = { { addr_.s6_addr[12],
        -:  137:    addr_.s6_addr[13], addr_.s6_addr[14], addr_.s6_addr[15] } };
        -:  138:  return address_v4(v4_bytes);
        -:  139:}
        -:  140:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  141:
        -:  142:bool address_v6::is_loopback() const BOOST_ASIO_NOEXCEPT
        -:  143:{
        -:  144:  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
        -:  145:      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
        -:  146:      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
        -:  147:      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
        -:  148:      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
        -:  149:      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
        -:  150:      && (addr_.s6_addr[12] == 0) && (addr_.s6_addr[13] == 0)
        -:  151:      && (addr_.s6_addr[14] == 0) && (addr_.s6_addr[15] == 1));
        -:  152:}
        -:  153:
        -:  154:bool address_v6::is_unspecified() const BOOST_ASIO_NOEXCEPT
        -:  155:{
        -:  156:  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
        -:  157:      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
        -:  158:      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
        -:  159:      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
        -:  160:      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
        -:  161:      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
        -:  162:      && (addr_.s6_addr[12] == 0) && (addr_.s6_addr[13] == 0)
        -:  163:      && (addr_.s6_addr[14] == 0) && (addr_.s6_addr[15] == 0));
        -:  164:}
        -:  165:
        -:  166:bool address_v6::is_link_local() const BOOST_ASIO_NOEXCEPT
        -:  167:{
        -:  168:  return ((addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0x80));
        -:  169:}
        -:  170:
        -:  171:bool address_v6::is_site_local() const BOOST_ASIO_NOEXCEPT
        -:  172:{
        -:  173:  return ((addr_.s6_addr[0] == 0xfe) && ((addr_.s6_addr[1] & 0xc0) == 0xc0));
        -:  174:}
        -:  175:
        -:  176:bool address_v6::is_v4_mapped() const BOOST_ASIO_NOEXCEPT
        -:  177:{
        -:  178:  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
        -:  179:      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
        -:  180:      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
        -:  181:      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
        -:  182:      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
        -:  183:      && (addr_.s6_addr[10] == 0xff) && (addr_.s6_addr[11] == 0xff));
        -:  184:}
        -:  185:
        -:  186:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  187:bool address_v6::is_v4_compatible() const
        -:  188:{
        -:  189:  return ((addr_.s6_addr[0] == 0) && (addr_.s6_addr[1] == 0)
        -:  190:      && (addr_.s6_addr[2] == 0) && (addr_.s6_addr[3] == 0)
        -:  191:      && (addr_.s6_addr[4] == 0) && (addr_.s6_addr[5] == 0)
        -:  192:      && (addr_.s6_addr[6] == 0) && (addr_.s6_addr[7] == 0)
        -:  193:      && (addr_.s6_addr[8] == 0) && (addr_.s6_addr[9] == 0)
        -:  194:      && (addr_.s6_addr[10] == 0) && (addr_.s6_addr[11] == 0)
        -:  195:      && !((addr_.s6_addr[12] == 0)
        -:  196:        && (addr_.s6_addr[13] == 0)
        -:  197:        && (addr_.s6_addr[14] == 0)
        -:  198:        && ((addr_.s6_addr[15] == 0) || (addr_.s6_addr[15] == 1))));
        -:  199:}
        -:  200:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  201:
        -:  202:bool address_v6::is_multicast() const BOOST_ASIO_NOEXCEPT
        -:  203:{
        -:  204:  return (addr_.s6_addr[0] == 0xff);
        -:  205:}
        -:  206:
        -:  207:bool address_v6::is_multicast_global() const BOOST_ASIO_NOEXCEPT
        -:  208:{
        -:  209:  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x0e));
        -:  210:}
        -:  211:
        -:  212:bool address_v6::is_multicast_link_local() const BOOST_ASIO_NOEXCEPT
        -:  213:{
        -:  214:  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x02));
        -:  215:}
        -:  216:
        -:  217:bool address_v6::is_multicast_node_local() const BOOST_ASIO_NOEXCEPT
        -:  218:{
        -:  219:  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x01));
        -:  220:}
        -:  221:
        -:  222:bool address_v6::is_multicast_org_local() const BOOST_ASIO_NOEXCEPT
        -:  223:{
        -:  224:  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x08));
        -:  225:}
        -:  226:
        -:  227:bool address_v6::is_multicast_site_local() const BOOST_ASIO_NOEXCEPT
        -:  228:{
        -:  229:  return ((addr_.s6_addr[0] == 0xff) && ((addr_.s6_addr[1] & 0x0f) == 0x05));
        -:  230:}
        -:  231:
        -:  232:bool operator==(const address_v6& a1, const address_v6& a2) BOOST_ASIO_NOEXCEPT
        -:  233:{
        -:  234:  using namespace std; // For memcmp.
        -:  235:  return memcmp(&a1.addr_, &a2.addr_,
        -:  236:      sizeof(boost::asio::detail::in6_addr_type)) == 0
        -:  237:    && a1.scope_id_ == a2.scope_id_;
        -:  238:}
        -:  239:
        -:  240:bool operator<(const address_v6& a1, const address_v6& a2) BOOST_ASIO_NOEXCEPT
        -:  241:{
        -:  242:  using namespace std; // For memcmp.
        -:  243:  int memcmp_result = memcmp(&a1.addr_, &a2.addr_,
        -:  244:      sizeof(boost::asio::detail::in6_addr_type));
        -:  245:  if (memcmp_result < 0)
        -:  246:    return true;
        -:  247:  if (memcmp_result > 0)
        -:  248:    return false;
        -:  249:  return a1.scope_id_ < a2.scope_id_;
        -:  250:}
        -:  251:
        -:  252:address_v6 address_v6::loopback() BOOST_ASIO_NOEXCEPT
        -:  253:{
        -:  254:  address_v6 tmp;
        -:  255:  tmp.addr_.s6_addr[15] = 1;
        -:  256:  return tmp;
        -:  257:}
        -:  258:
        -:  259:#if !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  260:address_v6 address_v6::v4_mapped(const address_v4& addr)
        -:  261:{
        -:  262:  address_v4::bytes_type v4_bytes = addr.to_bytes();
        -:  263:  bytes_type v6_bytes = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xFF, 0xFF,
        -:  264:    v4_bytes[0], v4_bytes[1], v4_bytes[2], v4_bytes[3] } };
        -:  265:  return address_v6(v6_bytes);
        -:  266:}
        -:  267:
        -:  268:address_v6 address_v6::v4_compatible(const address_v4& addr)
        -:  269:{
        -:  270:  address_v4::bytes_type v4_bytes = addr.to_bytes();
        -:  271:  bytes_type v6_bytes = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -:  272:    v4_bytes[0], v4_bytes[1], v4_bytes[2], v4_bytes[3] } };
        -:  273:  return address_v6(v6_bytes);
        -:  274:}
        -:  275:#endif // !defined(BOOST_ASIO_NO_DEPRECATED)
        -:  276:
        -:  277:address_v6 make_address_v6(const char* str)
        -:  278:{
        -:  279:  boost::system::error_code ec;
        -:  280:  address_v6 addr = make_address_v6(str, ec);
        -:  281:  boost::asio::detail::throw_error(ec);
        -:  282:  return addr;
        -:  283:}
        -:  284:
        1:  285:address_v6 make_address_v6(const char* str,
        -:  286:    boost::system::error_code& ec) BOOST_ASIO_NOEXCEPT
        -:  287:{
        -:  288:  address_v6::bytes_type bytes;
        1:  289:  unsigned long scope_id = 0;
        1:  290:  if (boost::asio::detail::socket_ops::inet_pton(
        2:  291:        BOOST_ASIO_OS_DEF(AF_INET6), str, &bytes[0], &scope_id, ec) <= 0)
        1:  291-block  0
        1:  292:    return address_v6();
        1:  292-block  0
    #####:  293:  return address_v6(bytes, scope_id);
    %%%%%:  293-block  0
        -:  294:}
        -:  295:
        -:  296:address_v6 make_address_v6(const std::string& str)
        -:  297:{
        -:  298:  return make_address_v6(str.c_str());
        -:  299:}
        -:  300:
        -:  301:address_v6 make_address_v6(const std::string& str,
        -:  302:    boost::system::error_code& ec) BOOST_ASIO_NOEXCEPT
        -:  303:{
        -:  304:  return make_address_v6(str.c_str(), ec);
        -:  305:}
        -:  306:
        -:  307:#if defined(BOOST_ASIO_HAS_STRING_VIEW)
        -:  308:
        -:  309:address_v6 make_address_v6(string_view str)
        -:  310:{
        -:  311:  return make_address_v6(static_cast<std::string>(str));
        -:  312:}
        -:  313:
        -:  314:address_v6 make_address_v6(string_view str,
        -:  315:    boost::system::error_code& ec) BOOST_ASIO_NOEXCEPT
        -:  316:{
        -:  317:  return make_address_v6(static_cast<std::string>(str), ec);
        -:  318:}
        -:  319:
        -:  320:#endif // defined(BOOST_ASIO_HAS_STRING_VIEW)
        -:  321:
        -:  322:address_v4 make_address_v4(
        -:  323:    v4_mapped_t, const address_v6& v6_addr)
        -:  324:{
        -:  325:  if (!v6_addr.is_v4_mapped())
        -:  326:  {
        -:  327:    bad_address_cast ex;
        -:  328:    boost::asio::detail::throw_exception(ex);
        -:  329:  }
        -:  330:
        -:  331:  address_v6::bytes_type v6_bytes = v6_addr.to_bytes();
        -:  332:  address_v4::bytes_type v4_bytes = { { v6_bytes[12],
        -:  333:    v6_bytes[13], v6_bytes[14], v6_bytes[15] } };
        -:  334:  return address_v4(v4_bytes);
        -:  335:}
        -:  336:
        -:  337:address_v6 make_address_v6(
        -:  338:    v4_mapped_t, const address_v4& v4_addr)
        -:  339:{
        -:  340:  address_v4::bytes_type v4_bytes = v4_addr.to_bytes();
        -:  341:  address_v6::bytes_type v6_bytes = { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        -:  342:    0xFF, 0xFF, v4_bytes[0], v4_bytes[1], v4_bytes[2], v4_bytes[3] } };
        -:  343:  return address_v6(v6_bytes);
        -:  344:}
        -:  345:
        -:  346:} // namespace ip
        -:  347:} // namespace asio
        -:  348:} // namespace boost
        -:  349:
        -:  350:#include <boost/asio/detail/pop_options.hpp>
        -:  351:
        -:  352:#endif // BOOST_ASIO_IP_IMPL_ADDRESS_V6_IPP
