        -:    0:Source:/usr/include/boost/asio/detail/impl/scheduler.ipp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/src/main.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/impl/scheduler.ipp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_IMPL_SCHEDULER_IPP
        -:   12:#define BOOST_ASIO_DETAIL_IMPL_SCHEDULER_IPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:
        -:   20:#include <boost/asio/detail/concurrency_hint.hpp>
        -:   21:#include <boost/asio/detail/event.hpp>
        -:   22:#include <boost/asio/detail/limits.hpp>
        -:   23:#include <boost/asio/detail/reactor.hpp>
        -:   24:#include <boost/asio/detail/scheduler.hpp>
        -:   25:#include <boost/asio/detail/scheduler_thread_info.hpp>
        -:   26:#include <boost/asio/detail/signal_blocker.hpp>
        -:   27:
        -:   28:#include <boost/asio/detail/push_options.hpp>
        -:   29:
        -:   30:namespace boost {
        -:   31:namespace asio {
        -:   32:namespace detail {
        -:   33:
        -:   34:class scheduler::thread_function
        -:   35:{
        -:   36:public:
    #####:   37:  explicit thread_function(scheduler* s)
    #####:   38:    : this_(s)
        -:   39:  {
    #####:   40:  }
        -:   41:
    #####:   42:  void operator()()
        -:   43:  {
    #####:   44:    boost::system::error_code ec;
    #####:   45:    this_->run(ec);
    %%%%%:   45-block  0
    #####:   46:  }
    %%%%%:   46-block  0
        -:   47:
        -:   48:private:
        -:   49:  scheduler* this_;
        -:   50:};
        -:   51:
        -:   52:struct scheduler::task_cleanup
        -:   53:{
        4:   54:  ~task_cleanup()
        4:   55:  {
        4:   56:    if (this_thread_->private_outstanding_work > 0)
        4:   56-block  0
        -:   57:    {
    #####:   58:      boost::asio::detail::increment(
    #####:   59:          scheduler_->outstanding_work_,
    #####:   60:          this_thread_->private_outstanding_work);
    %%%%%:   60-block  0
        -:   61:    }
        4:   62:    this_thread_->private_outstanding_work = 0;
        -:   63:
        -:   64:    // Enqueue the completed operations and reinsert the task at the end of
        -:   65:    // the operation queue.
        4:   66:    lock_->lock();
        4:   66-block  0
        4:   67:    scheduler_->task_interrupted_ = true;
        4:   68:    scheduler_->op_queue_.push(this_thread_->private_op_queue);
        4:   69:    scheduler_->op_queue_.push(&scheduler_->task_operation_);
        4:   70:  }
        -:   71:
        -:   72:  scheduler* scheduler_;
        -:   73:  mutex::scoped_lock* lock_;
        -:   74:  thread_info* this_thread_;
        -:   75:};
        -:   76:
        -:   77:struct scheduler::work_cleanup
        -:   78:{
        4:   79:  ~work_cleanup()
        4:   80:  {
        4:   81:    if (this_thread_->private_outstanding_work > 1)
        4:   81-block  0
        -:   82:    {
    #####:   83:      boost::asio::detail::increment(
    #####:   84:          scheduler_->outstanding_work_,
    #####:   85:          this_thread_->private_outstanding_work - 1);
    %%%%%:   85-block  0
        -:   86:    }
        4:   87:    else if (this_thread_->private_outstanding_work < 1)
        4:   87-block  0
        -:   88:    {
        4:   89:      scheduler_->work_finished();
        4:   89-block  0
        -:   90:    }
        4:   91:    this_thread_->private_outstanding_work = 0;
        -:   92:
        -:   93:#if defined(BOOST_ASIO_HAS_THREADS)
        4:   94:    if (!this_thread_->private_op_queue.empty())
        4:   94-block  0
        -:   95:    {
    #####:   96:      lock_->lock();
    %%%%%:   96-block  0
    #####:   97:      scheduler_->op_queue_.push(this_thread_->private_op_queue);
        -:   98:    }
        -:   99:#endif // defined(BOOST_ASIO_HAS_THREADS)
        4:  100:  }
        -:  101:
        -:  102:  scheduler* scheduler_;
        -:  103:  mutex::scoped_lock* lock_;
        -:  104:  thread_info* this_thread_;
        -:  105:};
        -:  106:
        1:  107:scheduler::scheduler(boost::asio::execution_context& ctx,
        1:  108:    int concurrency_hint, bool own_thread)
        -:  109:  : boost::asio::detail::execution_context_service_base<scheduler>(ctx),
        -:  110:    one_thread_(concurrency_hint == 1
        1:  111:        || !BOOST_ASIO_CONCURRENCY_HINT_IS_LOCKING(
        1:  111-block  0
        -:  112:          SCHEDULER, concurrency_hint)
       1*:  113:        || !BOOST_ASIO_CONCURRENCY_HINT_IS_LOCKING(
        1:  113-block  0
    %%%%%:  113-block  1
        1:  113-block  2
        -:  114:          REACTOR_IO, concurrency_hint)),
        1:  115:    mutex_(BOOST_ASIO_CONCURRENCY_HINT_IS_LOCKING(
        -:  116:          SCHEDULER, concurrency_hint)),
        -:  117:    task_(0),
        -:  118:    task_interrupted_(true),
        -:  119:    outstanding_work_(0),
        -:  120:    stopped_(false),
        -:  121:    shutdown_(false),
        -:  122:    concurrency_hint_(concurrency_hint),
        2:  123:    thread_(0)
        1:  123-block  0
        1:  123-block  1
        1:  123-block  2
        1:  123-block  3
    $$$$$:  123-block  4
    $$$$$:  123-block  5
    $$$$$:  123-block  6
    $$$$$:  123-block  7
    $$$$$:  123-block  8
        -:  124:{
        -:  125:  BOOST_ASIO_HANDLER_TRACKING_INIT;
        -:  126:
        1:  127:  if (own_thread)
        -:  128:  {
    #####:  129:    ++outstanding_work_;
    %%%%%:  129-block  0
    #####:  130:    boost::asio::detail::signal_blocker sb;
    $$$$$:  130-block  0
    #####:  131:    thread_ = new boost::asio::detail::thread(thread_function(this));
    %%%%%:  131-block  0
    %%%%%:  131-block  1
    $$$$$:  131-block  2
    $$$$$:  131-block  3
        -:  132:  }
        1:  133:}
        1:  133-block  0
        -:  134:
    #####:  135:scheduler::~scheduler()
        -:  136:{
    #####:  137:  if (thread_)
        -:  138:  {
    #####:  139:    thread_->join();
    #####:  140:    delete thread_;
        -:  141:  }
    #####:  142:}
------------------
_ZN5boost4asio6detail9schedulerD0Ev:
    #####:  135:scheduler::~scheduler()
        -:  136:{
        -:  137:  if (thread_)
        -:  138:  {
        -:  139:    thread_->join();
        -:  140:    delete thread_;
        -:  141:  }
    #####:  142:}
    %%%%%:  142-block  0
------------------
_ZN5boost4asio6detail9schedulerD2Ev:
    #####:  135:scheduler::~scheduler()
    %%%%%:  135-block  0
        -:  136:{
    #####:  137:  if (thread_)
    %%%%%:  137-block  0
        -:  138:  {
    #####:  139:    thread_->join();
    %%%%%:  139-block  0
    #####:  140:    delete thread_;
    %%%%%:  140-block  0
        -:  141:  }
    #####:  142:}
------------------
        -:  143:
    #####:  144:void scheduler::shutdown()
        -:  145:{
    #####:  146:  mutex::scoped_lock lock(mutex_);
    %%%%%:  146-block  0
    $$$$$:  146-block  1
    #####:  147:  shutdown_ = true;
    #####:  148:  if (thread_)
    #####:  149:    stop_all_threads(lock);
    %%%%%:  149-block  0
    #####:  150:  lock.unlock();
    %%%%%:  150-block  0
        -:  151:
        -:  152:  // Join thread to ensure task operation is returned to queue.
    #####:  153:  if (thread_)
    %%%%%:  153-block  0
        -:  154:  {
    #####:  155:    thread_->join();
    %%%%%:  155-block  0
    #####:  156:    delete thread_;
    %%%%%:  156-block  0
    %%%%%:  156-block  1
    #####:  157:    thread_ = 0;
    %%%%%:  157-block  0
        -:  158:  }
        -:  159:
        -:  160:  // Destroy handler objects.
    #####:  161:  while (!op_queue_.empty())
    %%%%%:  161-block  0
    %%%%%:  161-block  1
        -:  162:  {
    #####:  163:    operation* o = op_queue_.front();
    %%%%%:  163-block  0
    #####:  164:    op_queue_.pop();
    #####:  165:    if (o != &task_operation_)
    %%%%%:  165-block  0
    #####:  166:      o->destroy();
    %%%%%:  166-block  0
        -:  167:  }
        -:  168:
        -:  169:  // Reset to initial state.
    #####:  170:  task_ = 0;
    %%%%%:  170-block  0
    #####:  171:}
        -:  172:
        1:  173:void scheduler::init_task()
        -:  174:{
        2:  175:  mutex::scoped_lock lock(mutex_);
        1:  175-block  0
        1:  175-block  1
    $$$$$:  175-block  2
        1:  176:  if (!shutdown_ && !task_)
        1:  176-block  0
        -:  177:  {
        1:  178:    task_ = &use_service<reactor>(this->context());
        1:  178-block  0
        1:  179:    op_queue_.push(&task_operation_);
        1:  179-block  0
        1:  180:    wake_one_thread_and_unlock(lock);
        1:  180-block  0
        -:  181:  }
        1:  182:}
        -:  183:
        1:  184:std::size_t scheduler::run(boost::system::error_code& ec)
        -:  185:{
        1:  186:  ec = boost::system::error_code();
        1:  186-block  0
        1:  187:  if (outstanding_work_ == 0)
        -:  188:  {
    #####:  189:    stop();
    %%%%%:  189-block  0
    #####:  190:    return 0;
    %%%%%:  190-block  0
        -:  191:  }
        -:  192:
        2:  193:  thread_info this_thread;
        1:  193-block  0
    $$$$$:  193-block  1
        1:  194:  this_thread.private_outstanding_work = 0;
        2:  195:  thread_call_stack::context ctx(this, this_thread);
        1:  195-block  0
    $$$$$:  195-block  1
        -:  196:
        1:  197:  mutex::scoped_lock lock(mutex_);
        1:  197-block  0
    $$$$$:  197-block  1
        -:  198:
        1:  199:  std::size_t n = 0;
        5:  200:  for (; do_run_one(lock, this_thread, ec); lock.lock())
        5:  200-block  0
        5:  200-block  1
        4:  200-block  2
        4:  201:    if (n != (std::numeric_limits<std::size_t>::max)())
        4:  201-block  0
        4:  202:      ++n;
        4:  202-block  0
        1:  203:  return n;
        1:  203-block  0
        -:  204:}
        -:  205:
        -:  206:std::size_t scheduler::run_one(boost::system::error_code& ec)
        -:  207:{
        -:  208:  ec = boost::system::error_code();
        -:  209:  if (outstanding_work_ == 0)
        -:  210:  {
        -:  211:    stop();
        -:  212:    return 0;
        -:  213:  }
        -:  214:
        -:  215:  thread_info this_thread;
        -:  216:  this_thread.private_outstanding_work = 0;
        -:  217:  thread_call_stack::context ctx(this, this_thread);
        -:  218:
        -:  219:  mutex::scoped_lock lock(mutex_);
        -:  220:
        -:  221:  return do_run_one(lock, this_thread, ec);
        -:  222:}
        -:  223:
        -:  224:std::size_t scheduler::wait_one(long usec, boost::system::error_code& ec)
        -:  225:{
        -:  226:  ec = boost::system::error_code();
        -:  227:  if (outstanding_work_ == 0)
        -:  228:  {
        -:  229:    stop();
        -:  230:    return 0;
        -:  231:  }
        -:  232:
        -:  233:  thread_info this_thread;
        -:  234:  this_thread.private_outstanding_work = 0;
        -:  235:  thread_call_stack::context ctx(this, this_thread);
        -:  236:
        -:  237:  mutex::scoped_lock lock(mutex_);
        -:  238:
        -:  239:  return do_wait_one(lock, this_thread, usec, ec);
        -:  240:}
        -:  241:
        -:  242:std::size_t scheduler::poll(boost::system::error_code& ec)
        -:  243:{
        -:  244:  ec = boost::system::error_code();
        -:  245:  if (outstanding_work_ == 0)
        -:  246:  {
        -:  247:    stop();
        -:  248:    return 0;
        -:  249:  }
        -:  250:
        -:  251:  thread_info this_thread;
        -:  252:  this_thread.private_outstanding_work = 0;
        -:  253:  thread_call_stack::context ctx(this, this_thread);
        -:  254:
        -:  255:  mutex::scoped_lock lock(mutex_);
        -:  256:
        -:  257:#if defined(BOOST_ASIO_HAS_THREADS)
        -:  258:  // We want to support nested calls to poll() and poll_one(), so any handlers
        -:  259:  // that are already on a thread-private queue need to be put on to the main
        -:  260:  // queue now.
        -:  261:  if (one_thread_)
        -:  262:    if (thread_info* outer_info = static_cast<thread_info*>(ctx.next_by_key()))
        -:  263:      op_queue_.push(outer_info->private_op_queue);
        -:  264:#endif // defined(BOOST_ASIO_HAS_THREADS)
        -:  265:
        -:  266:  std::size_t n = 0;
        -:  267:  for (; do_poll_one(lock, this_thread, ec); lock.lock())
        -:  268:    if (n != (std::numeric_limits<std::size_t>::max)())
        -:  269:      ++n;
        -:  270:  return n;
        -:  271:}
        -:  272:
        -:  273:std::size_t scheduler::poll_one(boost::system::error_code& ec)
        -:  274:{
        -:  275:  ec = boost::system::error_code();
        -:  276:  if (outstanding_work_ == 0)
        -:  277:  {
        -:  278:    stop();
        -:  279:    return 0;
        -:  280:  }
        -:  281:
        -:  282:  thread_info this_thread;
        -:  283:  this_thread.private_outstanding_work = 0;
        -:  284:  thread_call_stack::context ctx(this, this_thread);
        -:  285:
        -:  286:  mutex::scoped_lock lock(mutex_);
        -:  287:
        -:  288:#if defined(BOOST_ASIO_HAS_THREADS)
        -:  289:  // We want to support nested calls to poll() and poll_one(), so any handlers
        -:  290:  // that are already on a thread-private queue need to be put on to the main
        -:  291:  // queue now.
        -:  292:  if (one_thread_)
        -:  293:    if (thread_info* outer_info = static_cast<thread_info*>(ctx.next_by_key()))
        -:  294:      op_queue_.push(outer_info->private_op_queue);
        -:  295:#endif // defined(BOOST_ASIO_HAS_THREADS)
        -:  296:
        -:  297:  return do_poll_one(lock, this_thread, ec);
        -:  298:}
        -:  299:
        1:  300:void scheduler::stop()
        -:  301:{
        2:  302:  mutex::scoped_lock lock(mutex_);
        1:  302-block  0
        1:  302-block  1
    $$$$$:  302-block  2
        1:  303:  stop_all_threads(lock);
        1:  304:}
        -:  305:
        -:  306:bool scheduler::stopped() const
        -:  307:{
        -:  308:  mutex::scoped_lock lock(mutex_);
        -:  309:  return stopped_;
        -:  310:}
        -:  311:
        -:  312:void scheduler::restart()
        -:  313:{
        -:  314:  mutex::scoped_lock lock(mutex_);
        -:  315:  stopped_ = false;
        -:  316:}
        -:  317:
        -:  318:void scheduler::compensating_work_started()
        -:  319:{
        -:  320:  thread_info_base* this_thread = thread_call_stack::contains(this);
        -:  321:  ++static_cast<thread_info*>(this_thread)->private_outstanding_work;
        -:  322:}
        -:  323:
        2:  324:void scheduler::post_immediate_completion(
        -:  325:    scheduler::operation* op, bool is_continuation)
        -:  326:{
        -:  327:#if defined(BOOST_ASIO_HAS_THREADS)
        2:  328:  if (one_thread_ || is_continuation)
        2:  328-block  0
        2:  328-block  1
        -:  329:  {
    #####:  330:    if (thread_info_base* this_thread = thread_call_stack::contains(this))
    %%%%%:  330-block  0
    %%%%%:  330-block  1
        -:  331:    {
    #####:  332:      ++static_cast<thread_info*>(this_thread)->private_outstanding_work;
    #####:  333:      static_cast<thread_info*>(this_thread)->private_op_queue.push(op);
    %%%%%:  333-block  0
    #####:  334:      return;
    %%%%%:  334-block  0
        -:  335:    }
        -:  336:  }
        -:  337:#else // defined(BOOST_ASIO_HAS_THREADS)
        -:  338:  (void)is_continuation;
        -:  339:#endif // defined(BOOST_ASIO_HAS_THREADS)
        -:  340:
        2:  341:  work_started();
        2:  341-block  0
        4:  342:  mutex::scoped_lock lock(mutex_);
        2:  342-block  0
    $$$$$:  342-block  1
        2:  343:  op_queue_.push(op);
        2:  344:  wake_one_thread_and_unlock(lock);
        2:  344-block  0
        -:  345:}
        -:  346:
        -:  347:void scheduler::post_deferred_completion(scheduler::operation* op)
        -:  348:{
        -:  349:#if defined(BOOST_ASIO_HAS_THREADS)
        -:  350:  if (one_thread_)
        -:  351:  {
        -:  352:    if (thread_info_base* this_thread = thread_call_stack::contains(this))
        -:  353:    {
        -:  354:      static_cast<thread_info*>(this_thread)->private_op_queue.push(op);
        -:  355:      return;
        -:  356:    }
        -:  357:  }
        -:  358:#endif // defined(BOOST_ASIO_HAS_THREADS)
        -:  359:
        -:  360:  mutex::scoped_lock lock(mutex_);
        -:  361:  op_queue_.push(op);
        -:  362:  wake_one_thread_and_unlock(lock);
        -:  363:}
        -:  364:
        1:  365:void scheduler::post_deferred_completions(
        -:  366:    op_queue<scheduler::operation>& ops)
        -:  367:{
        1:  368:  if (!ops.empty())
        1:  368-block  0
        -:  369:  {
        -:  370:#if defined(BOOST_ASIO_HAS_THREADS)
    #####:  371:    if (one_thread_)
    %%%%%:  371-block  0
        -:  372:    {
    #####:  373:      if (thread_info_base* this_thread = thread_call_stack::contains(this))
    %%%%%:  373-block  0
    %%%%%:  373-block  1
        -:  374:      {
    #####:  375:        static_cast<thread_info*>(this_thread)->private_op_queue.push(ops);
    %%%%%:  375-block  0
    #####:  376:        return;
    %%%%%:  376-block  0
        -:  377:      }
        -:  378:    }
        -:  379:#endif // defined(BOOST_ASIO_HAS_THREADS)
        -:  380:
    #####:  381:    mutex::scoped_lock lock(mutex_);
    %%%%%:  381-block  0
    %%%%%:  381-block  1
    $$$$$:  381-block  2
    #####:  382:    op_queue_.push(ops);
    #####:  383:    wake_one_thread_and_unlock(lock);
    %%%%%:  383-block  0
        -:  384:  }
        -:  385:}
        -:  386:
        -:  387:void scheduler::do_dispatch(
        -:  388:    scheduler::operation* op)
        -:  389:{
        -:  390:  work_started();
        -:  391:  mutex::scoped_lock lock(mutex_);
        -:  392:  op_queue_.push(op);
        -:  393:  wake_one_thread_and_unlock(lock);
        -:  394:}
        -:  395:
    #####:  396:void scheduler::abandon_operations(
        -:  397:    op_queue<scheduler::operation>& ops)
        -:  398:{
    #####:  399:  op_queue<scheduler::operation> ops2;
    %%%%%:  399-block  0
    %%%%%:  399-block  1
    $$$$$:  399-block  2
    #####:  400:  ops2.push(ops);
    #####:  401:}
        -:  402:
        9:  403:std::size_t scheduler::do_run_one(mutex::scoped_lock& lock,
        -:  404:    scheduler::thread_info& this_thread,
        -:  405:    const boost::system::error_code& ec)
        -:  406:{
        9:  407:  while (!stopped_)
        9:  407-block  0
        4:  407-block  1
        -:  408:  {
        8:  409:    if (!op_queue_.empty())
        8:  409-block  0
        -:  410:    {
        -:  411:      // Prepare to execute first handler from queue.
        8:  412:      operation* o = op_queue_.front();
        8:  412-block  0
        8:  413:      op_queue_.pop();
        8:  414:      bool more_handlers = (!op_queue_.empty());
        -:  415:
        8:  416:      if (o == &task_operation_)
        -:  417:      {
        4:  418:        task_interrupted_ = more_handlers;
        -:  419:
        4:  420:        if (more_handlers && !one_thread_)
        4:  420-block  0
        2:  420-block  1
        2:  421:          wakeup_event_.unlock_and_signal_one(lock);
        2:  421-block  0
        -:  422:        else
        2:  423:          lock.unlock();
        2:  423-block  0
        -:  424:
        4:  425:        task_cleanup on_exit = { this, &lock, &this_thread };
        4:  425-block  0
    $$$$$:  425-block  1
        -:  426:        (void)on_exit;
        -:  427:
        -:  428:        // Run the task. May throw an exception. Only block if the operation
        -:  429:        // queue is empty and we're not polling, otherwise we want to return
        -:  430:        // as soon as possible.
        4:  431:        task_->run(more_handlers ? 0 : -1, this_thread.private_op_queue);
        4:  431-block  0
        2:  431-block  1
        2:  431-block  2
        4:  431-block  3
        -:  432:      }
        -:  433:      else
        -:  434:      {
        4:  435:        std::size_t task_result = o->task_result_;
        -:  436:
        4:  437:        if (more_handlers && !one_thread_)
        4:  437-block  0
        4:  437-block  1
        4:  438:          wake_one_thread_and_unlock(lock);
        4:  438-block  0
        -:  439:        else
    #####:  440:          lock.unlock();
    %%%%%:  440-block  0
        -:  441:
        -:  442:        // Ensure the count of outstanding work is decremented on block exit.
    #####:  443:        work_cleanup on_exit = { this, &lock, &this_thread };
    $$$$$:  443-block  0
        -:  444:        (void)on_exit;
        -:  445:
        -:  446:        // Complete the operation. May throw an exception. Deletes the object.
        4:  447:        o->complete(this, ec, task_result);
        4:  447-block  0
        -:  448:
        4:  449:        return 1;
        4:  449-block  0
        -:  450:      }
        -:  451:    }
        -:  452:    else
        -:  453:    {
    #####:  454:      wakeup_event_.clear(lock);
    %%%%%:  454-block  0
    #####:  455:      wakeup_event_.wait(lock);
        -:  456:    }
        -:  457:  }
        -:  458:
        1:  459:  return 0;
        1:  459-block  0
        -:  460:}
        -:  461:
        -:  462:std::size_t scheduler::do_wait_one(mutex::scoped_lock& lock,
        -:  463:    scheduler::thread_info& this_thread, long usec,
        -:  464:    const boost::system::error_code& ec)
        -:  465:{
        -:  466:  if (stopped_)
        -:  467:    return 0;
        -:  468:
        -:  469:  operation* o = op_queue_.front();
        -:  470:  if (o == 0)
        -:  471:  {
        -:  472:    wakeup_event_.clear(lock);
        -:  473:    wakeup_event_.wait_for_usec(lock, usec);
        -:  474:    usec = 0; // Wait at most once.
        -:  475:    o = op_queue_.front();
        -:  476:  }
        -:  477:
        -:  478:  if (o == &task_operation_)
        -:  479:  {
        -:  480:    op_queue_.pop();
        -:  481:    bool more_handlers = (!op_queue_.empty());
        -:  482:
        -:  483:    task_interrupted_ = more_handlers;
        -:  484:
        -:  485:    if (more_handlers && !one_thread_)
        -:  486:      wakeup_event_.unlock_and_signal_one(lock);
        -:  487:    else
        -:  488:      lock.unlock();
        -:  489:
        -:  490:    {
        -:  491:      task_cleanup on_exit = { this, &lock, &this_thread };
        -:  492:      (void)on_exit;
        -:  493:
        -:  494:      // Run the task. May throw an exception. Only block if the operation
        -:  495:      // queue is empty and we're not polling, otherwise we want to return
        -:  496:      // as soon as possible.
        -:  497:      task_->run(more_handlers ? 0 : usec, this_thread.private_op_queue);
        -:  498:    }
        -:  499:
        -:  500:    o = op_queue_.front();
        -:  501:    if (o == &task_operation_)
        -:  502:    {
        -:  503:      if (!one_thread_)
        -:  504:        wakeup_event_.maybe_unlock_and_signal_one(lock);
        -:  505:      return 0;
        -:  506:    }
        -:  507:  }
        -:  508:
        -:  509:  if (o == 0)
        -:  510:    return 0;
        -:  511:
        -:  512:  op_queue_.pop();
        -:  513:  bool more_handlers = (!op_queue_.empty());
        -:  514:
        -:  515:  std::size_t task_result = o->task_result_;
        -:  516:
        -:  517:  if (more_handlers && !one_thread_)
        -:  518:    wake_one_thread_and_unlock(lock);
        -:  519:  else
        -:  520:    lock.unlock();
        -:  521:
        -:  522:  // Ensure the count of outstanding work is decremented on block exit.
        -:  523:  work_cleanup on_exit = { this, &lock, &this_thread };
        -:  524:  (void)on_exit;
        -:  525:
        -:  526:  // Complete the operation. May throw an exception. Deletes the object.
        -:  527:  o->complete(this, ec, task_result);
        -:  528:
        -:  529:  return 1;
        -:  530:}
        -:  531:
        -:  532:std::size_t scheduler::do_poll_one(mutex::scoped_lock& lock,
        -:  533:    scheduler::thread_info& this_thread,
        -:  534:    const boost::system::error_code& ec)
        -:  535:{
        -:  536:  if (stopped_)
        -:  537:    return 0;
        -:  538:
        -:  539:  operation* o = op_queue_.front();
        -:  540:  if (o == &task_operation_)
        -:  541:  {
        -:  542:    op_queue_.pop();
        -:  543:    lock.unlock();
        -:  544:
        -:  545:    {
        -:  546:      task_cleanup c = { this, &lock, &this_thread };
        -:  547:      (void)c;
        -:  548:
        -:  549:      // Run the task. May throw an exception. Only block if the operation
        -:  550:      // queue is empty and we're not polling, otherwise we want to return
        -:  551:      // as soon as possible.
        -:  552:      task_->run(0, this_thread.private_op_queue);
        -:  553:    }
        -:  554:
        -:  555:    o = op_queue_.front();
        -:  556:    if (o == &task_operation_)
        -:  557:    {
        -:  558:      wakeup_event_.maybe_unlock_and_signal_one(lock);
        -:  559:      return 0;
        -:  560:    }
        -:  561:  }
        -:  562:
        -:  563:  if (o == 0)
        -:  564:    return 0;
        -:  565:
        -:  566:  op_queue_.pop();
        -:  567:  bool more_handlers = (!op_queue_.empty());
        -:  568:
        -:  569:  std::size_t task_result = o->task_result_;
        -:  570:
        -:  571:  if (more_handlers && !one_thread_)
        -:  572:    wake_one_thread_and_unlock(lock);
        -:  573:  else
        -:  574:    lock.unlock();
        -:  575:
        -:  576:  // Ensure the count of outstanding work is decremented on block exit.
        -:  577:  work_cleanup on_exit = { this, &lock, &this_thread };
        -:  578:  (void)on_exit;
        -:  579:
        -:  580:  // Complete the operation. May throw an exception. Deletes the object.
        -:  581:  o->complete(this, ec, task_result);
        -:  582:
        -:  583:  return 1;
        -:  584:}
        -:  585:
        1:  586:void scheduler::stop_all_threads(
        -:  587:    mutex::scoped_lock& lock)
        -:  588:{
        1:  589:  stopped_ = true;
        1:  590:  wakeup_event_.signal_all(lock);
        1:  590-block  0
        -:  591:
       1*:  592:  if (!task_interrupted_ && task_)
    %%%%%:  592-block  0
        -:  593:  {
    #####:  594:    task_interrupted_ = true;
    #####:  595:    task_->interrupt();
    %%%%%:  595-block  0
        -:  596:  }
        1:  597:}
        -:  598:
        7:  599:void scheduler::wake_one_thread_and_unlock(
        -:  600:    mutex::scoped_lock& lock)
        -:  601:{
        7:  602:  if (!wakeup_event_.maybe_unlock_and_signal_one(lock))
        7:  602-block  0
        -:  603:  {
       7*:  604:    if (!task_interrupted_ && task_)
        7:  604-block  0
    %%%%%:  604-block  1
        -:  605:    {
    #####:  606:      task_interrupted_ = true;
    #####:  607:      task_->interrupt();
    %%%%%:  607-block  0
        -:  608:    }
        7:  609:    lock.unlock();
        7:  609-block  0
        -:  610:  }
        7:  611:}
        -:  612:
        -:  613:} // namespace detail
        -:  614:} // namespace asio
        -:  615:} // namespace boost
        -:  616:
        -:  617:#include <boost/asio/detail/pop_options.hpp>
        -:  618:
        -:  619:#endif // BOOST_ASIO_DETAIL_IMPL_SCHEDULER_IPP
