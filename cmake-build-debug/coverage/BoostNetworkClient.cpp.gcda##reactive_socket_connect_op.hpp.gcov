        -:    0:Source:/usr/include/boost/asio/detail/reactive_socket_connect_op.hpp
        -:    0:Graph:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcno
        -:    0:Data:/home/anthonytintul/CLionProjects/TLConsoleApplication/cmake-build-debug/CMakeFiles/TLConsoleApplication.dir/lib/BoostNetworkClient/BoostNetworkClient.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// detail/reactive_socket_connect_op.hpp
        -:    3:// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        -:    4://
        -:    5:// Copyright (c) 2003-2020 Christopher M. Kohlhoff (chris at kohlhoff dot com)
        -:    6://
        -:    7:// Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    8:// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:    9://
        -:   10:
        -:   11:#ifndef BOOST_ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
        -:   12:#define BOOST_ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
        -:   13:
        -:   14:#if defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   15:# pragma once
        -:   16:#endif // defined(_MSC_VER) && (_MSC_VER >= 1200)
        -:   17:
        -:   18:#include <boost/asio/detail/config.hpp>
        -:   19:#include <boost/asio/detail/bind_handler.hpp>
        -:   20:#include <boost/asio/detail/buffer_sequence_adapter.hpp>
        -:   21:#include <boost/asio/detail/fenced_block.hpp>
        -:   22:#include <boost/asio/detail/memory.hpp>
        -:   23:#include <boost/asio/detail/reactor_op.hpp>
        -:   24:#include <boost/asio/detail/socket_ops.hpp>
        -:   25:
        -:   26:#include <boost/asio/detail/push_options.hpp>
        -:   27:
        -:   28:namespace boost {
        -:   29:namespace asio {
        -:   30:namespace detail {
        -:   31:
        -:   32:class reactive_socket_connect_op_base : public reactor_op
        -:   33:{
        -:   34:public:
        1:   35:  reactive_socket_connect_op_base(socket_type socket, func_type complete_func)
        1:   36:    : reactor_op(&reactive_socket_connect_op_base::do_perform, complete_func),
        1:   37:      socket_(socket)
        1:   37-block  0
        -:   38:  {
        1:   39:  }
        -:   40:
        1:   41:  static status do_perform(reactor_op* base)
        -:   42:  {
        1:   43:    reactive_socket_connect_op_base* o(
        -:   44:        static_cast<reactive_socket_connect_op_base*>(base));
        -:   45:
        2:   46:    status result = socket_ops::non_blocking_connect(
       1*:   47:        o->socket_, o->ec_) ? done : not_done;
        1:   47-block  0
        1:   47-block  1
    %%%%%:   47-block  2
        -:   48:
        -:   49:    BOOST_ASIO_HANDLER_REACTOR_OPERATION((*o, "non_blocking_connect", o->ec_));
        -:   50:
        1:   51:    return result;
        1:   51-block  0
        -:   52:  }
        -:   53:
        -:   54:private:
        -:   55:  socket_type socket_;
        -:   56:};
        -:   57:
        -:   58:template <typename Handler, typename IoExecutor>
        -:   59:class reactive_socket_connect_op : public reactive_socket_connect_op_base
        -:   60:{
        -:   61:public:
        6:   62:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_connect_op);
------------------
_ZN5boost4asio6detail26reactive_socket_connect_opIZN18BoostNetworkClient16manageConnectionEvEUlRKNS_6system10error_codeEE_NS1_18io_object_executorINS0_8executorEEEE3ptr5resetEv:
        3:   62:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_connect_op);
        3:   62-block  0
        1:   62-block  1
        3:   62-block  2
        1:   62-block  3
        1:   62-block  4
        1:   62-block  5
        3:   62-block  6
    $$$$$:   62-block  7
------------------
_ZN5boost4asio6detail26reactive_socket_connect_opIZN18BoostNetworkClient16manageConnectionEvEUlRKNS_6system10error_codeEE_NS1_18io_object_executorINS0_8executorEEEE3ptrD2Ev:
        2:   62:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_connect_op);
        2:   62-block  0
------------------
_ZN5boost4asio6detail26reactive_socket_connect_opIZN18BoostNetworkClient16manageConnectionEvEUlRKNS_6system10error_codeEE_NS1_18io_object_executorINS0_8executorEEEE3ptr8allocateERS8_:
        1:   62:  BOOST_ASIO_DEFINE_HANDLER_PTR(reactive_socket_connect_op);
        1:   62-block  0
        1:   62-block  1
        1:   62-block  2
        1:   62-block  3
    $$$$$:   62-block  4
------------------
        -:   63:
        1:   64:  reactive_socket_connect_op(socket_type socket,
        -:   65:      Handler& handler, const IoExecutor& io_ex)
        -:   66:    : reactive_socket_connect_op_base(socket,
        -:   67:        &reactive_socket_connect_op::do_complete),
        -:   68:      handler_(BOOST_ASIO_MOVE_CAST(Handler)(handler)),
        1:   69:      io_executor_(io_ex)
        1:   69-block  0
        -:   70:  {
        1:   71:    handler_work<Handler, IoExecutor>::start(handler_, io_executor_);
        1:   72:  }
        -:   73:
        1:   74:  static void do_complete(void* owner, operation* base,
        -:   75:      const boost::system::error_code& /*ec*/,
        -:   76:      std::size_t /*bytes_transferred*/)
        -:   77:  {
        -:   78:    // Take ownership of the handler object.
        1:   79:    reactive_socket_connect_op* o
        -:   80:      (static_cast<reactive_socket_connect_op*>(base));
        2:   81:    ptr p = { boost::asio::detail::addressof(o->handler_), o, o };
        1:   81-block  0
    $$$$$:   81-block  1
        2:   82:    handler_work<Handler, IoExecutor> w(o->handler_, o->io_executor_);
        1:   82-block  0
    $$$$$:   82-block  1
        -:   83:
        -:   84:    BOOST_ASIO_HANDLER_COMPLETION((*o));
        -:   85:
        -:   86:    // Make a copy of the handler so that the memory can be deallocated before
        -:   87:    // the upcall is made. Even if we're not about to make an upcall, a
        -:   88:    // sub-object of the handler may be the true owner of the memory associated
        -:   89:    // with the handler. Consequently, a local copy of the handler is required
        -:   90:    // to ensure that any owning sub-object remains valid until after we have
        -:   91:    // deallocated the memory here.
        -:   92:    detail::binder1<Handler, boost::system::error_code>
        1:   93:      handler(o->handler_, o->ec_);
        1:   94:    p.h = boost::asio::detail::addressof(handler.handler_);
        1:   95:    p.reset();
        -:   96:
        -:   97:    // Make the upcall if required.
        1:   98:    if (owner)
        1:   98-block  0
        -:   99:    {
        2:  100:      fenced_block b(fenced_block::half);
        1:  100-block  0
        1:  100-block  1
    $$$$$:  100-block  2
        -:  101:      BOOST_ASIO_HANDLER_INVOCATION_BEGIN((handler.arg1_));
        1:  102:      w.complete(handler, handler.handler_);
        -:  103:      BOOST_ASIO_HANDLER_INVOCATION_END;
        -:  104:    }
        1:  105:  }
        -:  106:
        -:  107:private:
        -:  108:  Handler handler_;
        -:  109:  IoExecutor io_executor_;
        -:  110:};
        -:  111:
        -:  112:} // namespace detail
        -:  113:} // namespace asio
        -:  114:} // namespace boost
        -:  115:
        -:  116:#include <boost/asio/detail/pop_options.hpp>
        -:  117:
        -:  118:#endif // BOOST_ASIO_DETAIL_REACTIVE_SOCKET_CONNECT_OP_HPP
